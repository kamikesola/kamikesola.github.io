<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kamike</title>
  
  <subtitle>这是一个死宅的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.kamike.cn/"/>
  <updated>2019-03-29T14:29:16.584Z</updated>
  <id>blog.kamike.cn/</id>
  
  <author>
    <name>kamike</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编辑距离</title>
    <link href="blog.kamike.cn/dp_4/"/>
    <id>blog.kamike.cn/dp_4/</id>
    <published>2019-03-29T12:02:45.152Z</published>
    <updated>2019-03-29T14:29:16.584Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/29/ABVgl6.png" alt="ABVgl6.png"><br><a id="more"></a></p><h3 id="Given-two-words-word1-and-word2-find-the-minimum-number-of-operations-required-to-convert-word1-to-word2"><a href="#Given-two-words-word1-and-word2-find-the-minimum-number-of-operations-required-to-convert-word1-to-word2" class="headerlink" title="Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2."></a>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</h3><p>You have the following 3 operations permitted on a word:</p><p>  1.Insert a character<br>  2.Delete a character<br>  3.Replace a character</p><p>Example 1:</p><p>Input: word1 = “horse”, word2 = “ros”<br>Output: 3<br>Explanation:<br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)</p><p>Example 2:</p><p>Input: word1 = “intention”, word2 = “execution”<br>Output: 5<br>Explanation:<br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你两个字符串word1,word2.word1需要根据最少的操作来转换成word2,一共有3种操作:<br>1.replace:将字符串中某个字符转换成另一个字符.<br>2.remove:将字符串中某个字符移除.\<br>3.insert:将一个字符插入到字符串的任意位置.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><p>我们定义dp[i][j]来代表word1[0…j]转变成word2[0…i]需要的最少操作.<br>接下来就是找出关系式:<br>先来考虑三种操作如何表示:<br>1.替换:假设word1[0…i-1]与word2[0…j-1]已完成最少转换操作,并且word1[i]!=word2[j],那么我们将word1[i]替换成word[j],也就是dp[i-1][j-1]+1.<br>2.删除:假设word1[0…i-1]与word2[0…j]已完成最少转换操作,那么我们将word1[i]删除后使得它们仍然相等,也就是dp[i-1][j]+1.<br>3.插入:假设word1[0…i]与word2[0…j-1]已完成最少转换操作,那么我们将word1[i]中插入一个元素使得它们仍然相等,也就是dp[i][j-1]+1.</p><p>然后再考虑两种情况:<br>1.word1[i]==word2[j]:<br>那么需要取三种操作后的最小值(其中不需要替换操作):<br>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j]+1,dp[i][j-1]+1)<br>2.word1[i]!=word2[j]:<br>也是取三种操作的最小值:<br>dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1)</p><p>结合例子理解:</p><table><thead><tr><th style="text-align:center">word2\word1</th><th style="text-align:center">h</th><th style="text-align:center">o</th><th style="text-align:center">r</th><th style="text-align:center">s</th><th style="text-align:center">e  </th></tr></thead><tbody><tr><td style="text-align:center"> r</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4  </td></tr><tr><td style="text-align:center"> o</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4  </td></tr><tr><td style="text-align:center"> s</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">3  </td></tr></tbody></table><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1,String word2)</span><br><span class="line">&#123;</span><br><span class="line">      int m=word1.<span class="built_in">length</span>();</span><br><span class="line">      int n=word2.<span class="built_in">length</span>();</span><br><span class="line">      int[][] dp=new int[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++) dp[<span class="number">0</span>][<span class="built_in">i</span>]=<span class="built_in">i</span>;</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++) dp[<span class="built_in">i</span>][<span class="number">0</span>]=<span class="built_in">i</span>;</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(word1.charAt(<span class="built_in">i</span><span class="number">-1</span>)==word2.charAt(<span class="built_in">j</span><span class="number">-1</span>))</span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>],Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]+<span class="number">1</span>,dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>,Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]+<span class="number">1</span>,dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/29/ABVgl6.png&quot; alt=&quot;ABVgl6.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="dp" scheme="blog.kamike.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>通配符匹配</title>
    <link href="blog.kamike.cn/dp_3/"/>
    <id>blog.kamike.cn/dp_3/</id>
    <published>2019-03-29T11:02:31.431Z</published>
    <updated>2019-03-29T12:28:21.522Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/29/ABFFC6.png" alt="ABFFC6.png"><br><a id="more"></a></p><h3 id="Given-an-input-string-s-and-a-pattern-p-implement-wildcard-pattern-matching-with-support-for-‘-’-and-‘-’"><a href="#Given-an-input-string-s-and-a-pattern-p-implement-wildcard-pattern-matching-with-support-for-‘-’-and-‘-’" class="headerlink" title="Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’."></a>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</h3><p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).</p><p>The matching should cover the entire input string (not partial).</p><p>Note:</p><pre><code>s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like ? or *.</code></pre><p>Example 1:</p><p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p><p>Example 2:</p><p>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.</p><p>Example 3:</p><p>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.</p><p>Example 4:</p><p>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.</p><p>Example 5:</p><p>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>与前一道<a href="http://blog.kamike.cn/dp_1/">表达式匹配</a>类似，不过比那道要简单.<br>给你两个字符串s和p,要求s和P能够匹配,‘？’表示能与任何字符匹配,’*’表示一个任何的序列，包括空序列.<br>我们还是用动态规划来做.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们定义dp[i][j]为p的区间[0,i]与s的区间[0,j]是否匹配.<br>我们有两种情况:<br>1.dp[i][j]=dp[i-1][j] || (j&gt;0 &amp;&amp; dp[i][j-1]) || i==1,如果p[i-1]==’<em>‘.我们假设p[0…i-1]与s[0…j]已正确匹配,那么’</em>‘就代表空序列使得p[0…i]与s[0…j]继续匹配，我们又假设p[0…i]与s[0…j-1]已匹配,那么’*’继续延长序列使得p[0…i]与s[0…j]继续匹配.<br>2.dp[i][j]=(j&gt;0 &amp;&amp; dp[i-1][j-1] &amp;&amp; (p.charAt(i-1)==s.charAt(j-1) || p.charAt(i-1)==’?’)),如果p[i-1]==s[j-1]或p[i-1]==’?’.我们假设p[0…i-1]与s[0…j-1]已正确匹配,那么p[0…i]与s[0…j]匹配的充要条件就是p[i]=s[j].</p><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s,String p)</span><br><span class="line">&#123;</span><br><span class="line">    int m=p.<span class="built_in">length</span>();</span><br><span class="line">    int n=s.<span class="built_in">length</span>();</span><br><span class="line">    int[][] dp=new int[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>] || (<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]) || <span class="built_in">i</span>==<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=(<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (p.chaAt(<span class="built_in">i</span><span class="number">-1</span>)==s.charAt(<span class="built_in">j</span><span class="number">-1</span>) || p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'?'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/29/ABFFC6.png&quot; alt=&quot;ABFFC6.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="dp" scheme="blog.kamike.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最长合法括号</title>
    <link href="blog.kamike.cn/dp_2/"/>
    <id>blog.kamike.cn/dp_2/</id>
    <published>2019-03-27T08:34:08.695Z</published>
    <updated>2019-03-29T10:58:49.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/28/AwB7Sx.png" alt="AwB7Sx.png"><br><a id="more"></a></p><h3 id="Given-a-string-containing-just-the-characters-‘-‘-and-‘-’-find-the-length-of-the-longest-valid-well-formed-parentheses-substring"><a href="#Given-a-string-containing-just-the-characters-‘-‘-and-‘-’-find-the-length-of-the-longest-valid-well-formed-parentheses-substring" class="headerlink" title="Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring."></a>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</h3><p>Example 1:</p><p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”</p><p>Example 2:</p><p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个字符串s，返回它最长合法括号的长度。</p><p>(具体方法来自<a href="https://leetcode.com/problems/longest-valid-parentheses/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-valid-parentheses/solution/</a>)</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们用dp[i]来表示区间[0,i]中最长合法括号的长度.</p><p>接下来我们还是找出递推关系式：<br>1.dp[i]=dp[i-2]+2,如果s.charAt(i)==’)’ &amp;&amp; s.charAt(i-1)==’(‘.<br>这个很好理解，我们已经得到了dp[i-2]的值，表明区间[0,i-2]的合法括号长度，我们根据s[i-1]==’(‘和s[i]==’)’又得到一对括号，所以我们在dp[i-2]的基础上加上2.<br>2.dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2,如果s.charAt(i)==’)’ &amp;&amp; s.charAt(i-dp[i-1]-1)==’(‘.<br>现在我们得到了s[i-dp[i-1]-1]==’(‘与s[i]==’)’匹配，所以我们在dp[i-1]的长度基础上加上2,但此时[i-dp[i-1]-1,i]已经完全匹配，我们还要考虑与[0,i-dp[i-1]-2]的已经合法的长度对接，固还要加上dp[i-dp[i-1]-2].</p><p>以下是代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> longestValidParentheses(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">if</span>(s.charAt(i)==<span class="string">')'</span> &amp;&amp; s.charAt(i<span class="number">-1</span>)==<span class="string">'('</span>)  <span class="comment">//第一种情况</span></span><br><span class="line">         &#123;</span><br><span class="line">             dp[i]=(i&gt;=<span class="number">2</span>?dp[i<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;   <span class="comment">//注意i-2&gt;=0.</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i)==<span class="string">')'</span> &amp;&amp; s.charAt(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>)==<span class="string">'('</span>) <span class="comment">//第二种情况,i-dp[i-1]-1&gt;=0</span></span><br><span class="line">         &#123;</span><br><span class="line">             dp[i]=dp[i<span class="number">-1</span>]+(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>? dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;  <span class="comment">//i-dp[i-1]-2&gt;=0</span></span><br><span class="line">         &#125;</span><br><span class="line">         maxlen=Math.<span class="built_in">max</span>(maxlen,d[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合例子理解:</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">)</td><td style="text-align:center">)</td><td style="text-align:center">(</td><td style="text-align:center">(</td><td style="text-align:center">(</td><td style="text-align:center">)</td><td style="text-align:center">)  </td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">4  </td></tr></tbody></table><h3 id="两变量写法"><a href="#两变量写法" class="headerlink" title="两变量写法"></a>两变量写法</h3><p>我们用两个变量来维护，left和right，left表示匹配的’(‘个数，right表示匹配的’)’个数.<br>1.我们将left和right初始化0,从数组开头开始遍历:<br>(1).当遇到’(‘我们把left加一，遇到’)’我们把right加一.<br>(2).当left==right的时候，说明left数量与right数量已正确匹配，更新最大值为2<em>right.<br>(3).当right&gt;left，说明右括号数量比左括号多不匹配，我们把left和right都清0.<br>2.我们将left和right初始化为0，从数组末端开始遍历:<br>(1).同样当遇到’(‘我们把left加一，遇到’)’我们把right加一.<br>(2).当left==right的时候，说明left数量与right数量已正确匹配，更新最大值为2</em>left.<br>(3).当left&gt;right，说明左括号数量比右括号多,不匹配，我们把left和right都清0.<br>我们证明1.(3)和2.(3):<br>1.(3):<br>当left&gt;right，说明’(‘数量比’)’多，如果继续往右扩展我们还能碰到’)’,即能扩展合法空间,所以我们继续遍历.<br>当left&lt;right, 说明’)’数量比’(‘多, 那么我们遍历到的最后一个字符便是’)’,那么继续往右遍历我们会得到’)(‘或’))’,两者都无法使区间正确的扩展,所以我们把left和right清0.<br>2.(3):<br>同理当right&gt;left,因为是向左扩展,对于多出来的’)’,往左扩展我们还能碰到’(‘匹配.<br>当right&lt;left,那么我们遍历到的最后一个字符便是’(‘,那么继续往右遍历我们会得到’)(‘或’((‘，则不再有效，固left=right=0.</p><p>以下是代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int longestValidParentheses(<span class="type">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">max</span>=<span class="number">0</span>,<span class="keyword">left</span>=<span class="number">0</span>,<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)=='(') <span class="keyword">left</span>++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">right</span>++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span>==<span class="keyword">right</span>) <span class="built_in">max</span>=<span class="type">Math</span>.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="keyword">right</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span>) <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==')') <span class="keyword">right</span>++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">left</span>++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span>==<span class="keyword">right</span>) <span class="built_in">max</span>=<span class="type">Math</span>.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="keyword">left</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>) <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆栈写法"><a href="#堆栈写法" class="headerlink" title="堆栈写法"></a>堆栈写法</h3><p>我们还可以使用堆栈来写,每当我们遇到’(‘,我们把它的位置压栈,当遇到’)’,我们弹出栈顶元素,当栈顶不为空时我们更新长度,为空时我们把该位置压入栈.(思路与括号匹配类似，遇到右括号把左括号弹出，因为这边要记录长度，所以我们存储位置)</p><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; st=new Stack&lt;&gt;();</span><br><span class="line">    st.push(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;s.<span class="built_in">length</span>();<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="built_in">i</span>)==<span class="string">'('</span>)</span><br><span class="line">          st.push(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(<span class="built_in">i</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span>=Math.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="built_in">i</span>-st.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/28/AwB7Sx.png&quot; alt=&quot;AwB7Sx.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="dp" scheme="blog.kamike.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>表达式匹配</title>
    <link href="blog.kamike.cn/dp_1/"/>
    <id>blog.kamike.cn/dp_1/</id>
    <published>2019-03-26T13:25:36.599Z</published>
    <updated>2019-03-27T05:00:52.026Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/27/Aa26Mt.png" alt="Aa26Mt.png"><br><a id="more"></a></p><h3 id="Given-an-input-string-s-and-a-pattern-p-implement-regular-expression-matching-with-support-for-‘-’-and-‘-’"><a href="#Given-an-input-string-s-and-a-pattern-p-implement-regular-expression-matching-with-support-for-‘-’-and-‘-’" class="headerlink" title="Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’."></a>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</h3><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p><p>The matching should cover the entire input string (not partial).<br>Note:</p><pre><code>s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *.Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2:Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.Example 3:Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.Example 5:Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false</code></pre><hr><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你两个字符串s和p,要求p能与s匹配,’.’表示能与任何字符匹配,’<em>‘表示之前的字符能出现多次或着0次.注意’.’也能被重复,’.</em>‘能与任何字符串匹配.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>由于不是位置对应的匹配相等，我们只好分别判断某一段是否匹配，然后在前面匹配的条件下，来判断后面是否匹配.<br>具体思路请看<a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/c-on-space-dp" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/discuss/5684/c-on-space-dp</a><br>我们定义dp[i][j]为p的区间[0,i]与s的区间[0,j]是否匹配.<br>我们有三种情况:<br>1.dp[i][j]=dp[i-1][j-1],如果p[i-1]!=’<em>‘ &amp;&amp; (s[j-1]==p[i-1] || p[i-1] == ‘.’) 因为’.’能匹配任何字符<br>2.dp[i][j]=dp[i-2][j],如果p[i-1]==’</em>‘  ，因为’<em>‘能使前字符重复0次<br>3.dp[i][j]=dp[i][j-1] &amp;&amp; (s[j-1]==p[i-2] || p[i-2] == ‘.’),如果p[i-1]==’</em>‘，因为’<em>‘能使前字符重复多次.<br>我们来看例子<br>s=”ab”<br>p=”c</em>.*b”</p><table><thead><tr><th style="text-align:center">p\s</th><th style="text-align:center">“”</th><th style="text-align:center">a</th><th>b</th></tr></thead><tbody><tr><td style="text-align:center"> “”</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> c</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> *</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> .</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td>0</td><td></td></tr><tr><td style="text-align:center"> *</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td>0</td><td></td></tr><tr><td style="text-align:center"> b</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td>1</td><td></td></tr></tbody></table><p>由此关系式我们可以写出代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s,String p)</span><br><span class="line">&#123;</span><br><span class="line">    int m=p.<span class="built_in">length</span>();</span><br><span class="line">    int n=s.<span class="built_in">length</span>();</span><br><span class="line">    boolean[][] dp=new boolean[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'*'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=dp[<span class="built_in">i</span><span class="number">-2</span>][<span class="built_in">j</span>] || (<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (s.charAt(<span class="built_in">j</span><span class="number">-1</span>)==p.charAt(<span class="built_in">i</span><span class="number">-2</span>)||p.charAt(<span class="built_in">i</span><span class="number">-2</span>)==<span class="string">'.'</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=(<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (s.charAt(<span class="built_in">j</span><span class="number">-1</span>)==p.charAt(<span class="built_in">i</span><span class="number">-1</span>) || p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'.'</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/27/Aa26Mt.png&quot; alt=&quot;Aa26Mt.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="dp" scheme="blog.kamike.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="blog.kamike.cn/dp/"/>
    <id>blog.kamike.cn/dp/</id>
    <published>2019-03-24T13:00:46.998Z</published>
    <updated>2019-03-26T08:07:22.439Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/26/AN7dl4.png" alt="AN7dl4.png"><br><a id="more"></a></p><h3 id="Given-a-string-s-find-the-longest-palindromic-substring-in-s-You-may-assume-that-the-maximum-length-of-s-is-1000"><a href="#Given-a-string-s-find-the-longest-palindromic-substring-in-s-You-may-assume-that-the-maximum-length-of-s-is-1000" class="headerlink" title="Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000."></a>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</h3><hr><p>Example 1:<br><code>Input: &quot;babad&quot;</code><br><code>Output: &quot;bab&quot;</code><br><code>Note: &quot;aba&quot; is also a valid answer.</code><br>Example 2:<br><code>Input: &quot;cbbd&quot;</code><br><code>Output: &quot;bb&quot;</code></p><hr><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个字符串，返回它最长的回文子串(翻转后和自身相等的串)。</p><p>第一个能快速想到的方法就是暴力解法:</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法的核心思路就是枚举每一个字串，然后判断它是不是回文串，并记录它的长度，并更新长度的最大值.<br>以下是判断是不是回文串的代码,因为回文串关于<code>中心对称</code>，我们只要判断两边的字符是否相等，如果有不相等，直接判断为不是.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPalindrome(String s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)  <span class="comment">//len/2表示我们只要判断一半.</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(s.charAt(i)!=s.charAt(len-i<span class="number">-1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//遇到关于中心对称的两端不相等的，直接返回false；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//所有判断都通过，返回true;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是逐个枚举并调用以上<code>isPalindrome</code>函数.我们定义两个变量i,j;i表示枚举子串的左端点,j表示枚举子串的右端点.i∈[0,len),j∈[i,len).(i&lt;=j,左端点值小于右端点)<br>那么我们使用两个for循环来遍历区间位置:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindromicSubstring(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">String</span> res=<span class="string">""</span>; <span class="comment">//存储长度最大的回文串</span></span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">if</span>(isPalindrome(s.substring(i,j+<span class="number">1</span>))) <span class="comment">//substring方法区间取值是前闭后开，所以我们取[i,j+1).</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">if</span>(j+<span class="number">1</span>-i&gt;res.length()) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过三个循环，我们很容易得出时间复杂度是O(n^3),空间复杂度为O(1).</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>暴力解法的时间复杂度这么高，原因是遍历了每一种可能.那么其中就会有重复判断或者避免判断的子串.<br>动态规划的核心思想就是根据已有的条件，通过推导公式，推导出结果，那么我们就减少了很多重复的判断<br>比如说:<code>&quot;cabddbac&quot;中，我们用暴力解法时，&#39;abddba&#39;与&#39;bddb&#39;我们重复判断了&#39;d&#39;==&#39;d&#39;与&#39;b&#39;==&#39;b&#39;</code>.<br>那么我们如何避免重复判断呢?对于变动的左右断点形成的区间，我们定义一个<code>二维数组dp[len][len](len表示原字符串的长度).</code><br>我们用<code>dp[i][j]=1来表示区间[i,j]是回文串</code>.那么如何根据存储的条件，推出未知条件呢,<br>\begin{cases}<br>dp[i][j]=1, &amp;(i==j\or(j==i+1\and\s.charAt(j)==s.charAt(i)))<br>\end{cases}<br>\begin{cases}<br>dp[i][j]=dp[i+1][j-1], &amp;(s.charAt(j)==s.charAt(i)\and\j-i&gt;2)<br>\end{cases}<br>固我们根据该递推式来写出代码<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindromicSubstring(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(s.length()==<span class="number">0</span>) <span class="built_in">return</span> <span class="string">""</span>;   <span class="comment">//如果字符串s为空，则输出空字符串</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,maxlen=<span class="number">0</span>,len=s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">if</span>(i==j || (s.charAt(i)==s.charAt(j) &amp;&amp; i==j+<span class="number">1</span>))  <span class="comment">//两个条件的判断</span></span><br><span class="line">           &#123;</span><br><span class="line">              dp[j][i]=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">if</span>(i-j&gt;=<span class="number">2</span> &amp;&amp; s.charAt(i)==s.charAt(j))</span><br><span class="line">           &#123;</span><br><span class="line">              dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">if</span>(dp[j][i]==<span class="number">1</span> &amp;&amp; maxlen&lt;i+<span class="number">1</span>-j)  <span class="comment">//记录最大区间</span></span><br><span class="line">           &#123;</span><br><span class="line">              left=j;</span><br><span class="line">              right=i+<span class="number">1</span>;</span><br><span class="line">              maxlen=i+<span class="number">1</span>-j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> s.substring(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容易看出时间和空间复杂度都是O(n^2)</p><h3 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h3><p>现在我们换种暴力解法的思路,我们以<code>字符串的一个字符为中心</code>，向两边不断<code>扩展</code>，以此来得到最长的回文串.<br>比如字符串”aba”:<br><code>1.取第一个字符&#39;a&#39;:两边无相同元素，无法继续扩展，所以长度为1.</code><br><code>2.取第二个字符&#39;b&#39;:两边都有相同元素&#39;a&#39;,所以我们扩展至长度为3,继续扩展，发现达到边界，无法扩展，所以此时最长为&#39;aba&#39;.</code><br><code>3.取第三个字符&#39;a&#39;:两边无相同元素，无法继续扩展，所以长度为1</code><br>固我们得到最长回文串为’aba’.<br>但我们会发现有个问题，那就是如果我们取偶数长度的字符串’abba’:我们会发现没有对称中心，所以这种方法是不是就不能适用这种情况了呢.</p><p>下面就是<code>马拉车算法</code>奇妙的地方了,我们首先对字符串做优先处理，在字符与字符之间<code>插入一个字符&#39;#&#39;</code>,我们就能保证字符串的长度就是<code>奇数个</code>了，比如说刚才我们举得例子<code>&#39;abba&#39;</code>，进行处理后我们得到<code>&#39;#a#b#b#a#&#39;</code>,那么我们就有了对称中心’#’，就能继续使用刚才的暴力解法了.我们设<code>len[i]的值为字符串以第i个字符为中心的最长回文半径</code>，<code>mx为最长回文子串的最后端点的位置</code>,<code>id为最长回文子串的对称中心点</code>.<br>我们就拿’#a#b#b#a#’举例:<br><code>1.第一个字符&#39;#&#39;:无法扩展，半径为1,此时mx更新为0,id为0</code><br><code>2.第二个字符&#39;a&#39;:能扩展到两边&#39;#&#39;，半径为2，此时mx更新为2，id为1</code><br><code>2.第三个字符&#39;#&#39;:无法扩展，半径为1,半径不是最大，不改变</code><br><code>3.第四个字符&#39;b&#39;:能扩展到两边&#39;#&#39;，半径为2，此时不更新</code><br><code>4.第五个字符&#39;#&#39;:能扩展到最两端的&#39;#&#39;，半径为5,此时更新mx为8,id为4</code><br><code>5.第六个字符&#39;b&#39;:我们发现此时i&lt;mx(6&lt;8)，我们发现此时中心&#39;b&#39;处在最大的回文子串之中,那么我们是不是还需要继续循环往外重复扩展呢.我们可以根据已知的最长回文子串&#39;#a#b#b#a#&#39;可知两边是对称的,所以右边的&#39;b&#39;与左边的&#39;b&#39;对称，那么半径就是从2开始扩展</code><br>后面相同的思想，略过<br>···</p><p>那么我们来看一般情况:<br>假设我们遍历到的对称中心<code>i&lt;mx</code>:<br>我用画图软件随便画了一下:<br><img src="https://s2.ax1x.com/2019/03/26/ANIjXR.png" alt="ANIjXR.png"><br>我们可以得到此时i与2<em>id-i是对称的，那么len[i]的起始半径要不就是<code>mx-i</code>,要么就是`len[2</em>id-i]`<br>那么我们取哪个呢，小的那个:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下我们用反证法来证明一下:</span><br><span class="line">假设len[<span class="number">2</span>*<span class="built_in">id</span>-i]&gt;mx-i,len[<span class="built_in">id</span>]=mx-i.</span><br><span class="line">我们有len[i]=len[<span class="number">2</span>*<span class="built_in">id</span>-i]</span><br><span class="line">那么我们继续以<span class="built_in">id</span>为对称中心,由于此时[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>,i]都是以<span class="built_in">id</span>为中心的回文串，又len[i]=len[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>],两者也关于<span class="built_in">id</span>对称，</span><br><span class="line">那么我们可以把<span class="built_in">id</span>为对称中心的半径扩展到len[<span class="built_in">id</span>]=len[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>]+i-<span class="built_in">id</span>&gt;mx-i,这与假设len[<span class="built_in">id</span>]=mx-i矛盾,固我们取较小的那个</span><br></pre></td></tr></table></figure></p><p>那么我们还有另一种情况’i&gt;=mx’：<br>此时没有办法，只能老老实实向外扩展</p><p>以下是完整代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindromicSubstring(String s)</span><br><span class="line">&#123;</span><br><span class="line">   String str=<span class="string">"#"</span>;</span><br><span class="line">   <span class="keyword">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>,maxlen=<span class="number">0</span>,maxid=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] <span class="built_in">len</span>=<span class="built_in">new</span> <span class="keyword">int</span>[<span class="number">2</span>*s.length()+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">   &#123;</span><br><span class="line">     str+=s.charAt(i)+<span class="string">"#"</span>;   <span class="comment">//字符串之间插入'#'</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(i&lt;mx) <span class="built_in">len</span>[i]=Math.min(mx-i, <span class="built_in">len</span>[<span class="number">2</span>*id-i]);  <span class="comment">//第一种情况</span></span><br><span class="line">     while(i-<span class="built_in">len</span>[i]&gt;=<span class="number">0</span> &amp;&amp; i+<span class="built_in">len</span>[i]&lt;=str.length()<span class="number">-1</span> &amp;&amp; str.charAt(i-<span class="built_in">len</span>[i])==str.charAt(i+<span class="built_in">len</span>[i])) <span class="built_in">len</span>[i]++;</span><br><span class="line">     <span class="keyword">if</span>(mx&lt;<span class="built_in">len</span>[i]+i)  <span class="comment">//更新</span></span><br><span class="line">     &#123;</span><br><span class="line">       id=i;</span><br><span class="line">       mx=<span class="built_in">len</span>[i]+i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(maxlen&lt;<span class="built_in">len</span>[i]) <span class="comment">//更新最大长度</span></span><br><span class="line">     &#123;</span><br><span class="line">       maxlen=<span class="built_in">len</span>[i];</span><br><span class="line">       maxid=i;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.substring((maxid-maxlen+<span class="number">1</span>)/<span class="number">2</span>,(maxid+maxlen)/<span class="number">2</span>);  <span class="comment">//返回最大回文串的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度和空间复杂度均为O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/26/AN7dl4.png&quot; alt=&quot;AN7dl4.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="blog.kamike.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="dp" scheme="blog.kamike.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>总结java反射(二)</title>
    <link href="blog.kamike.cn/reflect2/"/>
    <id>blog.kamike.cn/reflect2/</id>
    <published>2019-03-23T00:41:07.140Z</published>
    <updated>2019-03-23T11:59:51.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/23/AGMjBR.jpg" alt="AGMjBR.jpg"><br><a id="more"></a></p><h1 id="分析类能力"><a href="#分析类能力" class="headerlink" title="分析类能力:"></a>分析类能力:</h1><p>在上一章简略(十分简略)的介绍了反射的机制,那么这一节我们具体介绍反射机制的重要内容—-<code>检查类的结构</code>.</p><hr><p>要了解java中类的结构，我们都知道类包括三个结构:<code>Field(数据域:常量，全局变量),Method(类方法),Constructor(类构造器)</code>.</p><p>好的，我们偷懒复制上一节的🗡类来做个例子:</p><hr><p>以下是🗡的数据域：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">//🗡的等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> durability;  <span class="comment">//🗡的耐久度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> attack;  <span class="comment">//🗡的攻击力</span></span><br></pre></td></tr></table></figure></p><hr><p>以下是🗡的类方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123; <span class="comment">//获取等级</span></span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDurability</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取耐久度</span></span><br><span class="line">  <span class="keyword">return</span> durability;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttack</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取攻击力</span></span><br><span class="line">  <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strenthen</span><span class="params">()</span> </span>&#123;  <span class="comment">//强化🗡的等级</span></span><br><span class="line">  <span class="keyword">int</span> random=(<span class="keyword">int</span>) (Math.random()+<span class="number">1</span>);</span><br><span class="line">  level+=random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以下是🗡的构造器:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sword()&#123;</span><br><span class="line">  <span class="keyword">this</span>.level=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.durability=<span class="number">150</span>;</span><br><span class="line">  <span class="keyword">this</span>.attack=<span class="number">150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>那么我们如何用反射机制来获得🗡类的结构呢?</p><h2 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包:"></a>reflect包:</h2><p>在java.lang.reflect包中有三个类Field,Method和Constructor分别用于描述类的域，方法和构造器.<br>具体来看它们之间的关系:<br><a href="https://imgchr.com/i/AGMl01" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/23/AGMl01.md.png" alt="AGMl01.md.png"></a><br>可以看到Field,Method,Constructor都继承AccesibleObject类，并实现Number接口。</p><p>首先我们来看它们的共同父类<code>AccessibleObject</code>类:</p><h3 id="AccessibleObject类"><a href="#AccessibleObject类" class="headerlink" title="AccessibleObject类:"></a><em>AccessibleObject类</em>:</h3><p>它有最常用且核心的三个方法:<br>1.<code>void setAccesible(boolean flag)</code><br>为反射的对象设置可访问标志.flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置.<br>也就是说可以篡改🗡的等级和耐久度了(如此病态)<br>2.<code>boolean isAccessible()</code><br>返回反射对象的可访问标志的值.是private就返回false,是public就返回true.<br>3.<code>static void setAccesible(AccessibleObject[] array,boolean flag)</code><br>这个就更狠了，静态方法，能够快捷地对对象数组设置可访问标志</p><hr><p>简单了解了AccessibleObject类后，我们来看它们都实现的接口:Number.</p><h3 id="Number接口"><a href="#Number接口" class="headerlink" title="Number接口:"></a><em>Number接口</em>:</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> Member&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *表明一个类或接口中所有公共成员的集合</span></span><br><span class="line"><span class="comment">    *包括继承(派生)的成员</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PUBLIC</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *表明一个类或接口中声明成员的集合</span></span><br><span class="line"><span class="comment">    *不包括继承(派生)的成员</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DECLARED = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回实现了该接口的类或接口的Class类对象(参考第一节所提到的Class类)</span></span><br><span class="line"><span class="comment">     * 并声明成员或构造器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; getDeclaringClass();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回实现该接口的成员或构造器的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> String getName();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Java语言中对成员或构造器的解析值(int常量).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getModifiers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码摘抄自JavaSE-10的源码.<br>我们着重看<code>getModifiers()</code>这个方法，它返回一个类或接口的解析int值，那它具体代表什么呢?<br>这里就不得不要提到一个解析类<code>Modifier</code>:</p><h3 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类:"></a><em>Modifier类</em>:</h3><p>首先看Modifier类中的常量部分<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PUBLIC</span>       = <span class="number">0</span>x00000001;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PRIVATE</span>      = <span class="number">0</span>x00000002;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PROTECTED</span>    = <span class="number">0</span>x00000004;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">STATIC</span>       = <span class="number">0</span>x00000008;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">FINAL</span>        = <span class="number">0</span>x00000010;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">SYNCHRONIZED</span> = <span class="number">0</span>x00000020;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">VOLATILE</span>     = <span class="number">0</span>x00000040;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">TRANSIENT</span>    = <span class="number">0</span>x00000080;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">NATIVE</span>       = <span class="number">0</span>x00000100;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">INTERFACE</span>    = <span class="number">0</span>x00000200;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">ABSTRACT</span>     = <span class="number">0</span>x00000400;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRICT       = <span class="number">0</span>x00000800;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BRIDGE    = <span class="number">0</span>x00000040;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VARARGS   = <span class="number">0</span>x00000080;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0</span>x00001000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION  = <span class="number">0</span>x00002000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0</span>x00004000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANDATED  = <span class="number">0</span>x00008000;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASS_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.<span class="keyword">FINAL</span>   |</span><br><span class="line">        Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERFACE_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTRUCTOR_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> METHOD_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.<span class="keyword">FINAL</span>   |</span><br><span class="line">        Modifier.<span class="keyword">SYNCHRONIZED</span>   | Modifier.<span class="keyword">NATIVE</span>       | Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIELD_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">STATIC</span>         | Modifier.<span class="keyword">FINAL</span>        | Modifier.<span class="keyword">TRANSIENT</span> |</span><br><span class="line">        Modifier.<span class="keyword">VOLATILE</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARAMETER_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">FINAL</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACCESS_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">PROTECTED</span> | Modifier.<span class="keyword">PRIVATE</span>;</span><br></pre></td></tr></table></figure></p><p>可以看出每一个类型都有对应的16进制int值对应,并通过:<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPublic(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PUBLIC) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrivate(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PRIVATE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isProtected(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PROTECTED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isStatic(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; STATIC) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isFinal(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; FINAL) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isSynchronized(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; SYNCHRONIZED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isVolatile(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; VOLATILE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isTransient(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isNative(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; NATIVE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isInterface(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; INTERFACE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isAbstract(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; ABSTRACT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isStrict(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; STRICT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>一系列判断的静态方法，来确定类型(返回值,类,接口,常量类型).<br>最后通过toString()方法打印:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static String toString(int mod) &#123;</span><br><span class="line">        StringJoiner sj = new StringJoiner(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PUBLIC) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"public"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PROTECTED) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"protected"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PRIVATE) != 0)       sj.<span class="builtin-name">add</span>(<span class="string">"private"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; ABSTRACT) != 0)      sj.<span class="builtin-name">add</span>(<span class="string">"abstract"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; STATIC) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"static"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; FINAL) != 0)         sj.<span class="builtin-name">add</span>(<span class="string">"final"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; TRANSIENT) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"transient"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; VOLATILE) != 0)      sj.<span class="builtin-name">add</span>(<span class="string">"volatile"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; SYNCHRONIZED) != 0)  sj.<span class="builtin-name">add</span>(<span class="string">"synchronized"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; NATIVE) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"native"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; STRICT) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"strictfp"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; INTERFACE) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"interface"</span>);</span><br><span class="line"></span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类:"></a><em>Field类</em>:</h3><p><code>Field[] getFields()</code><br><code>Field[] getDeclaredFields()</code><br>getFields方法返回一个包含Field对象的数组，记录这个类或其超类的公有域。getDeclaredFields方法也返回包含Fields对象的数组，记录这个类的全部域。如果没有数据域，则将返回一个长度为0的数组。<br><code>Class getType()</code><br>返回数据域对应类型的Class类<br>下面我们通过这些方法来获得🗡类的数据域</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> Sword s=new Sword();</span><br><span class="line"> <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line"> String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());  <span class="comment">//通过解析器获得cl的访问类型.</span></span><br><span class="line"> <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName()); <span class="comment">//输出🗡类名字</span></span><br><span class="line"> System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line"> printFields(<span class="keyword">cl</span>);  <span class="comment">//打印🗡类的数据域</span></span><br><span class="line"> System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public static void printFields(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line"> Field[] fields=<span class="keyword">cl</span>.getDeclaredFields();  <span class="comment">//获得🗡类的全部数据域</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(Field f:fields)  <span class="comment">//遍历每个数据</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">Class</span> <span class="keyword">type</span>=f.getType();  <span class="comment">//获得数据类型的Class对象</span></span><br><span class="line">  String name=f.getName();  <span class="comment">//获取数据的名字</span></span><br><span class="line">  System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);  </span><br><span class="line">  String modifiers=Modifier.<span class="keyword">toString</span>(f.getModifiers()); <span class="comment">//通过解析器获得cl的访问类型</span></span><br><span class="line">  <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span>);</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="keyword">type</span>.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>); <span class="comment">//输出对应类型和名字</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是输出结果<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> <span class="keyword"> public</span> core.Sword</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="built_in"> int </span>level;</span><br><span class="line">   <span class="keyword"> private</span><span class="built_in"> int </span>durability;</span><br><span class="line">   <span class="built_in"> int </span>attack;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类:"></a><em>Method类</em>:</h3><p>同样<br><code>Method[] getMethods()</code><br><code>Method[] getDeclaredMethods()</code><br>返回包含Method对象的数组：getMethods返回所有公有方法,包括从超类继承来的公有方法;getDeclaredMethods返回这个类或接口的全部方法，但不包括由超类继承来的方法<br><code>Class getReturnType()</code><br>描述方法返回类型的Class对象<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Sword s=new Sword(10,150,10);</span><br><span class="line">    <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line">    String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());</span><br><span class="line">    <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName());</span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">    <span class="comment">//printFields(cl);</span></span><br><span class="line">    printMethods(<span class="keyword">cl</span>); <span class="comment">//打印方法</span></span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public static void printMethods(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line">Method[] methods=<span class="keyword">cl</span>.getDeclaredMethods(); <span class="comment">//获得所有声明的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Method <span class="keyword">m</span>:methods)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Class</span> retType=<span class="keyword">m</span>.getReturnType(); <span class="comment">//获得方法的返回值类型</span></span><br><span class="line">String name=<span class="keyword">m</span>.getName();  <span class="comment">//获取方法名</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);</span><br><span class="line">String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">m</span>.getModifiers()); <span class="comment">//获取访问权限</span></span><br><span class="line"><span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers+<span class="string">" "</span>);  <span class="comment">//打印访问权限</span></span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(retType.getName() + <span class="string">" "</span> +name + <span class="string">"("</span>);  <span class="comment">//打印方法名和返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span>[] paramTypes = <span class="keyword">m</span>.getParameterTypes();  <span class="comment">//取得方法的参数</span></span><br><span class="line"><span class="keyword">for</span>(int j=0;j&lt;paramTypes.length;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">", "</span>);</span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName()); <span class="comment">//打印参数</span></span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  <span class="comment">//public core.Sword</span></span><br><span class="line">  <span class="comment">//&#123;</span></span><br><span class="line">      <span class="comment">//public int getAttack();</span></span><br><span class="line">      <span class="comment">//public void strenthen();</span></span><br><span class="line">      <span class="comment">//public int getDurability();</span></span><br><span class="line">      <span class="comment">//public int getLevel();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类:"></a><em>Constructor类</em>:</h3><p><code>Constructor[] getConstructors()</code><br><code>Constructor[] getDeclaredConstructors()</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Sword s=new Sword(10,150,10);</span><br><span class="line">    <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line">    String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());</span><br><span class="line">    <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName());</span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">    <span class="comment">//printFields(cl);</span></span><br><span class="line">    <span class="comment">//printMethods(cl);</span></span><br><span class="line">      printConstructors(<span class="keyword">cl</span>);  <span class="comment">//打印构造器</span></span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public static void printConstructors(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Constructor[] constructors=<span class="keyword">cl</span>.getDeclaredConstructors(); <span class="comment">//获取所有声明的构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Constructor c:constructors)</span><br><span class="line">    &#123;</span><br><span class="line">        String name=c.getName(); <span class="comment">//取得构造器名字</span></span><br><span class="line">        System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);</span><br><span class="line">            String modifiers=Modifier.<span class="keyword">toString</span>(c.getModifiers());  <span class="comment">//获取访问权限</span></span><br><span class="line">            <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers+<span class="string">" "</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] paramTypes=c.getParameterTypes(); <span class="comment">//获取参数</span></span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;paramTypes.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">","</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName());  <span class="comment">//打印参数名</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//public core.Sword</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//public core.Sword(int,int,int);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><hr><p>以上是反射三个包的具体应用<br>下一章我们使用反射改写数组的复制代码.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/23/AGMjBR.jpg&quot; alt=&quot;AGMjBR.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="blog.kamike.cn/categories/java/"/>
    
    
      <category term="反射" scheme="blog.kamike.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>总结java反射(一)</title>
    <link href="blog.kamike.cn/hello-world/"/>
    <id>blog.kamike.cn/hello-world/</id>
    <published>2018-12-28T09:10:47.441Z</published>
    <updated>2019-03-23T12:00:18.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/17/Ae4vG9.jpg" alt="古明地觉"><br><a id="more"></a></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射:"></a><strong>反射</strong>:</h1><p>反射库是java中能够动态的操纵java代码的程序，这种能分析类能力的程序被称为反射(reflective).<br>那么反射具体有哪些反射机制呢？</p><p>首先来说Class类</p><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>在程序运行期间，有着记录对象所属的类的信息的类，那就是Class类。</p><hr><h3 id="四个重要方法"><a href="#四个重要方法" class="headerlink" title="四个重要方法:"></a>四个重要方法:</h3><p>Object类中有一个方法<code>getClass()</code> ，它能返回Class类型的实例：<br>现在让我们来创建一个简单的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">//🗡的等级</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> durability;  <span class="comment">//🗡的耐久度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> attack;  <span class="comment">//🗡的攻击力</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.level=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">this</span>.durability=<span class="number">150</span>;</span><br><span class="line">     <span class="keyword">this</span>.attack=<span class="number">150</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123; <span class="comment">//获取等级</span></span><br><span class="line">     <span class="keyword">return</span> level;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDurability</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取耐久度</span></span><br><span class="line">     <span class="keyword">return</span> durability;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttack</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取攻击力</span></span><br><span class="line">     <span class="keyword">return</span> attack;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strenthen</span><span class="params">()</span> </span>&#123;  <span class="comment">//强化🗡的等级</span></span><br><span class="line">     <span class="keyword">int</span> random=(<span class="keyword">int</span>) (Math.random()+<span class="number">1</span>);</span><br><span class="line">     level+=random;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们简单的建完了我们的<code>🗡</code>类。</p><hr><p>接下来我们用<code>getClass()</code>方法获取剑的Class类的实例。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sword</span> s=<span class="function"><span class="keyword">new</span> <span class="title">Sword</span>();</span></span><br><span class="line"><span class="function"><span class="title">Class</span> <span class="title">cl</span>=<span class="title">s</span>.<span class="title">getClass</span>();</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(s.getClass().<span class="title">getName</span>());  <span class="comment">//输出结果为sword.Sword</span></span></span><br></pre></td></tr></table></figure></p><p>以上我们用到了Class类最常用的方法，<code>getName()</code>,它用来返回类的名字.格式为<code>包名.类名</code>.</p><hr><p>如果我们要在程序运行期间读取Class对象，我们可以使用Class类中的<code>forName()</code>方法：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  String className=<span class="string">"sword.Sword"</span>;</span><br><span class="line">  <span class="keyword">Class</span> cl=<span class="keyword">Class</span>.forName(className);</span><br><span class="line">  System.out.<span class="keyword">println</span>(cl.getName()); <span class="comment">//输出同上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上面使用try块来检查异常，原因是因为className可能为<code>不存在</code>的类.</p><hr><p>反射库中还有一个非常实用的方法newInstance(),它用来创建一个类的实例。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">s</span><span class="selector-class">.getClass</span>()<span class="selector-class">.newInstance</span>();</span><br></pre></td></tr></table></figure></p><p>不过<code>newInstance()</code>方法需要调用默认的构造器，如果这个类没有默认的构造器，就会<code>抛出一个异常</code></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><em><code>java.lang.Class</code></em><br>1.static Class forName(String className)<br>  <code>返回描述类名为className的Class对象。</code><br>2.Object newInstance()<br>  <code>返回这个类的一个新实例。</code><br>3.Class getClass()<br>  <code>返回这个类的Class对象。</code><br>4.String getName()<br>  <code>返回该Class对象的类名。</code></p><hr><p>待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/17/Ae4vG9.jpg&quot; alt=&quot;古明地觉&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="blog.kamike.cn/categories/java/"/>
    
    
      <category term="反射" scheme="blog.kamike.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
