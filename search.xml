<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不同子序列</title>
      <link href="/dp_9/"/>
      <url>/dp_9/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/04/07/AfDSFs.jpg" alt="AfDSFs.jpg"><br><a id="more"></a></p><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>“ACE”</code> is a subsequence of <code>“ABCDE”</code> while <code>“AEC”</code> is not).</p><p><strong>Example 1:</strong></p><pre><strong>Input: </strong>S = <code>"rabbbit"</code>, T = <code>"rabbit"<strong>Output:</strong>&nbsp;3</code><strong>Explanation:</strong>As shown below, there are 3 ways you can generate "rabbit" from S.(The caret symbol ^ means the chosen letters)<code>rabbbit</code>^^^^ ^^<code>rabbbit</code>^^ ^^^^<code>rabbbit</code>^^^ ^^^</pre><p><strong>Example 2:</strong></p><pre><strong>Input: </strong>S = <code>"babgbag"</code>, T = <code>"bag"<strong>Output:</strong>&nbsp;5</code><strong>Explanation:</strong>As shown below, there are 5 ways you can generate "bag" from S.(The caret symbol ^ means the chosen letters)<code>babgbag</code>^^ ^<code>babgbag</code>^^    ^<code>babgbag</code>^    ^^<code>babgbag</code>  ^  ^^<code>babgbag</code>    ^^^</pre><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>给你两个字符串S和T,寻找S中有多少个子序列与T相等.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>老样子对于两个字符串的匹配问题，建立二维数组dp[i][j]:<br>表示S[0…j]与T[0…i]的子序列相等个数.<br>那么递推式就是<code>dp[i][j]=dp[i][j-1]+(s.charAt(j-1)==t.charAt(i-1)?dp[i-1][j-1]:0)</code><br>以下是代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> numDistinct(<span class="keyword">String</span> s, <span class="keyword">String</span> t) &#123;</span><br><span class="line">       <span class="keyword">int</span> m=s.length();</span><br><span class="line">     <span class="keyword">int</span> n=t.length();</span><br><span class="line">     <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)  <span class="comment">//向前遍历寻找相同的字符</span></span><br><span class="line">      &#123;</span><br><span class="line">       dp[i][j]=dp[i][j<span class="number">-1</span>] + (s.charAt(j<span class="number">-1</span>)==t.charAt(i<span class="number">-1</span>)?dp[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交错字符串</title>
      <link href="/dp_8/"/>
      <url>/dp_8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/AfDdpt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/07/AfDdpt.png" alt="AfDdpt.png"></a><br><a id="more"></a></p><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p></p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", <em>s3</em> = "aadbbcbcac"<strong>Output:</strong> true</pre><p><strong>Example 2:</strong></p><p><pre><strong>Input:</strong> s1 = “aabcc”, s2 = “dbbca”, <em>s3</em> = “aadbbbaccc”<br><strong>Output:</strong> false</pre></p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>给你三个字符串s1,s2,s3,判断s3是否由s1,s2交错组成(即保持原字符串原来的顺序).</p><h3 id="递归-记忆化"><a href="#递归-记忆化" class="headerlink" title="递归+记忆化"></a>递归+记忆化</h3><p>刚开始只能想到三指针i,j,k分别判断s1[i]==s3[k] || s2[j]==s3[k],如果相等，就对应的指针自增1.<br>但很快就发现不对,当遍历到s1[i]==s2[j]==s3[k]的时候要分出两条岔路<br>所以两种情况需要递归:<br>以下是代码(三指针加递归):<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> <span class="keyword">boolean </span>isInterleave(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>,<span class="keyword">String </span><span class="built_in">s3</span>)&#123;</span><br><span class="line">    <span class="meta">if</span>(<span class="built_in">s3</span>.length()!<span class="symbol">=s1</span>.length()+<span class="built_in">s2</span>.length()) return false<span class="comment">; //如果长度加起来不相等，就直接返回</span></span><br><span class="line">    return helper(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">public</span> <span class="keyword">boolean </span>helper(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>,<span class="keyword">String </span><span class="built_in">s3</span>,int x,int y,int z)&#123;  //x,y,z为三指针</span><br><span class="line">    <span class="keyword">boolean </span>res<span class="symbol">=true</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span>(z&lt;<span class="built_in">s3</span>.length())</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="meta">if</span>(x&lt;<span class="built_in">s1</span>.length() &amp;&amp; y&lt;<span class="built_in">s2</span>.length() &amp;&amp; <span class="built_in">s1</span>.charAt(x)=<span class="symbol">=s3</span>.charAt(z) &amp;&amp; <span class="built_in">s2</span>.charAt(y)=<span class="symbol">=s3</span>.charAt(z))&#123;</span><br><span class="line">             res<span class="symbol">=helper</span>(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,x+<span class="number">1</span>,y,z+<span class="number">1</span>) <span class="title">||</span> helper(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,x,y+<span class="number">1</span>,z+<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">             <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>        &#125;</span><br><span class="line">         <span class="meta">if</span>(x&lt;<span class="built_in">s1</span>.length() &amp;&amp; <span class="built_in">s1</span>.charAt(x)=<span class="symbol">=s3</span>.charAt(z))&#123;</span><br><span class="line">             x++<span class="comment">;</span></span><br><span class="line">             z++<span class="comment">;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">else</span> <span class="meta">if</span>(y&lt;<span class="built_in">s2</span>.length() &amp;&amp; <span class="built_in">s2</span>.charAt(y)=<span class="symbol">=s3</span>.charAt(z))&#123;</span><br><span class="line">             y++<span class="comment">;</span></span><br><span class="line">             z++<span class="comment">;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             res<span class="symbol">=false</span><span class="comment">;</span></span><br><span class="line">             <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果发现有两组样例过不了,重复的字符太多导致了超时(2333).<br>然后无奈找不到如何记忆化搜索,就找网上大神了:<br>发现需要用set来记录出现过的失败情况，那么怎么记录呢，<code>int index=x*s3.length()+y</code>表示在s3中递归失败的位置<br>有三种情况:<br>1.该位置在集合Set中存在，直接返回<br>2.s1,s2其中一个指针到达末尾，比较另一个字符后面部分与s3后面部分是否相等.<br>3.递归遍历分岔的情况<br>以下是代码:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">boolean </span>isInterleave(String <span class="built_in">s1</span>,String <span class="built_in">s2</span>,String <span class="built_in">s3</span>)&#123;</span><br><span class="line">    if(<span class="built_in">s3</span>.length()!=<span class="built_in">s1</span>.length()+<span class="built_in">s2</span>.length())  return false<span class="comment">;</span></span><br><span class="line">    Set&lt;Integer&gt; set=new HashSet&lt;&gt;()<span class="comment">;</span></span><br><span class="line">    return helper(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,set)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">boolean </span>helper(String <span class="built_in">s1</span>,String <span class="built_in">s2</span>,String <span class="built_in">s3</span>,int x,int y,int z,Set&lt;Integer&gt; set)&#123;</span><br><span class="line">    int code=x*<span class="built_in">s3</span>.length()+y<span class="comment">;</span></span><br><span class="line">    if(set.contains(code)) return false<span class="comment">;</span></span><br><span class="line">    if(x==<span class="built_in">s1</span>.length()) return <span class="built_in">s2</span>.<span class="keyword">substring(y, </span><span class="built_in">s2</span>.length()).equals(<span class="built_in">s3</span>.<span class="keyword">substring(z, </span><span class="built_in">s3</span>.length()))<span class="comment">;</span></span><br><span class="line">    if(y==<span class="built_in">s2</span>.length()) return <span class="built_in">s1</span>.<span class="keyword">substring(x, </span><span class="built_in">s1</span>.length()).equals(<span class="built_in">s3</span>.<span class="keyword">substring(z, </span><span class="built_in">s3</span>.length()))<span class="comment">;</span></span><br><span class="line">    if(<span class="built_in">s1</span>.charAt(x)==<span class="built_in">s3</span>.charAt(z) &amp;&amp; helper(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,x+<span class="number">1</span>,y,z+<span class="number">1</span>,set) <span class="title">||</span> <span class="built_in">s2</span>.charAt(y)==<span class="built_in">s3</span>.charAt(z) &amp;&amp;                 </span><br><span class="line">       helper(<span class="built_in">s1</span>,<span class="built_in">s2</span>,<span class="built_in">s3</span>,x,y+<span class="number">1</span>,z+<span class="number">1</span>,set)) return true<span class="comment">;</span></span><br><span class="line">    set.<span class="keyword">add(code);</span></span><br><span class="line"><span class="keyword"> </span>   return false<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><p>根据递归的思路,我们也就很容易想到动态规划了:<br>我们建立二维数组dp[i][j].<br>i:表示s1[0…i]与s3是否正确匹配.<br>j:表示s2[0…j]与s3是否正确匹配.</p><p>那么可以推出关系式:<br>dp[i][j]=dp[i-1][j] &amp;&amp; s1.charAt(i-1)==s3.charAt(i-1+j) || dp[i][j-1] &amp;&amp; s2.charAt(j-1)==s3.charAt(i+j-1)<br>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterleave(String s1,String s2,String s3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s3.<span class="built_in">length</span>()!=s1.<span class="built_in">length</span>()+s2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="built_in">false</span>;</span><br><span class="line">    int m=s1.<span class="built_in">length</span>();</span><br><span class="line">int n=s2.<span class="built_in">length</span>();</span><br><span class="line">boolean[][] dp=new boolean[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">true</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">   dp[<span class="built_in">i</span>][<span class="number">0</span>]=dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(<span class="built_in">i</span><span class="number">-1</span>)==s3.charAt(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">   dp[<span class="number">0</span>][<span class="built_in">i</span>]=dp[<span class="number">0</span>][<span class="built_in">i</span><span class="number">-1</span>] &amp;&amp; s2.charAt(<span class="built_in">i</span><span class="number">-1</span>)==s3.charAt(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">  &#123;</span><br><span class="line">    dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>] &amp;&amp; s1.charAt(<span class="built_in">i</span><span class="number">-1</span>)==s3.charAt(<span class="built_in">i</span><span class="number">-1</span>+<span class="built_in">j</span>) || dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; s2.charAt(<span class="built_in">j</span><span class="number">-1</span>)==s3.charAt(<span class="built_in">i</span>+<span class="built_in">j</span><span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同的二叉搜索树Ⅰ和Ⅱ</title>
      <link href="/dp_7/"/>
      <url>/dp_7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/AfBvwQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/07/AfBvwQ.jpg" alt="AfBvwQ.jpg"></a><br><a id="more"></a></p><h3 id="Given-n-how-many-structurally-unique-BST’s-binary-search-trees-that-store-values-1-…-n"><a href="#Given-n-how-many-structurally-unique-BST’s-binary-search-trees-that-store-values-1-…-n" class="headerlink" title="Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?"></a>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</h3><pre><strong>Input:</strong> 3<strong>Output:</strong> 5<strong>Explanation:</strong>Given <em>n</em> = 3, there are a total of 5 unique BST's:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>给你一个整数n,输出[1…n]组成的所有可能的二叉搜索树的种数.</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>对于二叉树,我们选择不同的根结点,就会生成不同的二叉树:<br>所以我们可以循环遍历不同的根,作为根节点,并递归遍历左结点和右结点,并根据乘法原理计算种数.<br>以下是代码<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> numTrees(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       <span class="keyword">sum</span>+=numTrees(i<span class="number">-1</span>)*numTrees(n-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然，暴力递归明显会超时,我们需要优化:<br>我们先来看递归树(拿n=3举例)<br>i=1的情况:</p><pre>                         numTrees(3)              /           \        numTrees(0)    numTrees(2)                       /         \                  numTrees(0)   numTrees(1)                                 /        \                            numTrees(0)  numTrees(0)</pre>    i=2的情况:<pre>               numTrees(3)              /           \         numTrees(1)    numTrees(1)         /         \    /         \    numTrees(0)   numTrees(0)    numTrees(0)              </pre><p>发现numTrees(1)和numTrees(0)都有重复.固我们可以动态规划记录已经计算过的值:</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> numTrees(<span class="built_in">int</span> n)&#123;</span><br><span class="line">     <span class="built_in">int</span>[] <span class="built_in">num</span>=<span class="keyword">new</span> <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">     <span class="built_in">num</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">num</span>[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="built_in">num</span>[i]+=<span class="built_in">num</span>[j]*<span class="built_in">num</span>[i-j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">num</span>[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看第二个问题:</p><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 …&nbsp;<em>n</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> 3<strong>Output:</strong>[&nbsp; [1,null,3,2],&nbsp; [3,2,null,1],&nbsp; [3,1,null,null,2],&nbsp; [2,1,3],&nbsp; [1,null,2,null,3]]<strong>Explanation:</strong>The above output corresponds to the 5 unique BST's shown below:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre><h2 id="题意分析-1"><a href="#题意分析-1" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>这次加大了难度，输出所有的可能情况.<br>思路还是差不多，递归遍历左右子树:<br>但我们发现,递归的子树会有多种返回情况,而返回值只有一个,我们可以使用列表保存起来.<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;TreeNode&gt; generateTrees(<span class="keyword">int</span> n)&#123;</span><br><span class="line">     <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//如果n==0,直接返回空列表</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> helper(<span class="number">1</span>,n);   <span class="comment">//递归遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;TreeNode&gt; helper(<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//记录所有情况</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)&#123;  <span class="comment">//若区间左端点大于右端点，则为该结点为null,并返回</span></span><br><span class="line">       res.add(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;TreeNode&gt; left=helper(start,i<span class="number">-1</span>);  <span class="comment">//遍历左子树,区间为[start,i-1]</span></span><br><span class="line">        <span class="keyword">List</span>&lt;TreeNode&gt; right=helper(i+<span class="number">1</span>,end);  <span class="comment">//遍历右子树,区间为[i+1,end]</span></span><br><span class="line">        <span class="keyword">for</span>(TreeNode l:left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode r:right)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode root=<span class="keyword">new</span> TreeNode(i);  <span class="comment">//根节点</span></span><br><span class="line">                root.left=l;  <span class="comment">//根节点左子树</span></span><br><span class="line">                root.right=r;  <span class="comment">//根节点右子树</span></span><br><span class="line">                res.add(root); <span class="comment">//记录各种情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">//返回各种情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扰乱字符串</title>
      <link href="/dp_6/"/>
      <url>/dp_6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/04/07/AfBTJI.jpg" alt="AfBTJI.jpg"><br><a id="more"></a></p><h3 id="Given-a-string-s1-we-may-represent-it-as-a-binary-tree-by-partitioning-it-to-two-non-empty-substrings-recursively"><a href="#Given-a-string-s1-we-may-represent-it-as-a-binary-tree-by-partitioning-it-to-two-non-empty-substrings-recursively" class="headerlink" title="Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively."></a>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</h3><p>Below is one possible representation of <em>s1</em> = <code>“great”</code>:</p><pre>    great   /    \  gr    eat / \    /  \g   r  e   at           / \          a   t</pre><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>“gr”</code> and swap its two children, it produces a scrambled string <code>“rgeat”</code>.</p><pre>    rgeat   /    \  rg    eat / \    /  \r   g  e   at           / \          a   t</pre><p>We say that <code>“rgeat”</code> is a scrambled string of <code>“great”</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>“eat”</code> and <code>“at”</code>, it produces a scrambled string <code>“rgtae”</code>.</p><pre>    rgtae   /    \  rg    tae / \    /  \r   g  ta  e       / \      t   a</pre><p>We say that <code>“rgtae”</code> is a scrambled string of <code>“great”</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p><p><strong>Example 1:</strong></p><p><pre><strong>Input:</strong> s1 = “great”, s2 = “rgeat”<br><strong>Output:</strong> true</pre></p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个字符串,将它分割成二叉树的形式，任意交换两个孩子结点，判断是否能得到目标字符串。</p><p>(方法参考于<a href="https://www.cnblogs.com/grandyang/p/4318500.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4318500.html</a>)</p><h3 id="递归-剪枝"><a href="#递归-剪枝" class="headerlink" title="递归+剪枝"></a>递归+剪枝</h3><p>我们使用递归枚举所有情况，并适当做判断，排除显然不可能的情况，来优化运行的效率.</p><p>我们就拿题目中的例子举例:<br>s1=”abcde”,s2=”caebd”<br>1.因为分割的位置并不能确定，所以我们对每个位置进行分割(两个字符串一起分割),以下是将第一个字母分离开来:<br><code>s1</code>:abcde分成<code>a</code>与<code>bcde</code><br><code>s2</code>:caebd分成<code>c</code>与<code>aebd</code>或者<code>caeb</code>与<code>d</code><br>注意，为什么我们需要对s2进行两种情况的分法，是因为可能存在孩子结点交换的情况,两种情况都可能是与原字符串匹配的.<br>2.然后我们比较两个子树是否相等,也就是比较<code>a</code>==<code>c</code> &amp;&amp; <code>bcde</code>==<code>aebd</code> || <code>a</code>==<code>d</code> &amp;&amp; <code>aebd</code>==<code>caeb</code>.<br>3.如果不相等我们继续对子树当成新的<code>s1与s2</code>，并继续进行分割也就是说s1=<code>bcde</code>,s2=<code>aebd</code>或者s1=<code>bcde</code>,s2=<code>caeb</code>.不过我们发现<code>a</code>与<code>c</code>无法继续分，我们可以加上一个条件使其直接返回.<br>(下面情况类似，不再继续说明)···</p><p>然后我们就能写出相应代码(未优化):<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> isScramble(<span class="keyword">String</span> s1,<span class="keyword">String</span> s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()!=s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//如果长度不相等,我们直接返回.</span></span><br><span class="line">    <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//比较两个子树是否相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;s1.length();i++)  <span class="comment">//循环遍历对每个位置都进行分割</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">String</span> left1=s1.substring(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">String</span> right1=s1.substring(i);</span><br><span class="line">        <span class="keyword">String</span> left2=s2.substring(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">String</span> right2=s2.substring(i);</span><br><span class="line">        <span class="keyword">if</span>(isScramble(left1,left2) &amp;&amp; isScramble(right1,right2)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//第一种情况的判断</span></span><br><span class="line">        left2=s2.substring(s2.length()-i);   <span class="comment">//第二种情况的分割</span></span><br><span class="line">        right2=s2.substring(<span class="number">0</span>,s2.length()-i);</span><br><span class="line">        <span class="keyword">if</span>(isScramble(left1,left2) &amp;&amp; isScramble(right1,right2)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//第二种情况的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//其中包括字符只有一个情况的返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还能进行优化，可以发现，当发现两个子树的字符串排序后进行比较，若不相同直接进行返回.<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">boolean </span>isScramble(String <span class="built_in">s1</span>,String <span class="built_in">s2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    if(<span class="built_in">s1</span>.length()!=<span class="built_in">s2</span>.length()) return false<span class="comment">;</span></span><br><span class="line">    if(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>)) return true<span class="comment">;</span></span><br><span class="line">    char[] a=<span class="built_in">s1</span>.toCharArray()<span class="comment">;    //对子树字符串进行排序</span></span><br><span class="line">    char[] <span class="keyword">b=s2.toCharArray();</span></span><br><span class="line"><span class="keyword"> </span>   Arrays.sort(a)<span class="comment">;</span></span><br><span class="line">    Arrays.sort(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword"> </span>   for(int i=<span class="number">0</span><span class="comment">;i&lt;a.length;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">    if(a[i]!=<span class="keyword">b[i]) </span>return false<span class="comment">;   //又不想等的字符，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">1</span><span class="comment">;i&lt;s1.length();i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">    String left1=<span class="built_in">s1</span>.<span class="keyword">substring(0, </span>i)<span class="comment">;</span></span><br><span class="line">    String right1=<span class="built_in">s1</span>.<span class="keyword">substring(i);</span></span><br><span class="line"><span class="keyword"> </span>   String left2=<span class="built_in">s2</span>.<span class="keyword">substring(0, </span>i)<span class="comment">;</span></span><br><span class="line">    String right2=<span class="built_in">s2</span>.<span class="keyword">substring(i);</span></span><br><span class="line"><span class="keyword"> </span>   if(isScramble(left1,left2) &amp;&amp; isScramble(right1,right2)) return true<span class="comment">;</span></span><br><span class="line">    left2=<span class="built_in">s2</span>.<span class="keyword">substring(s2.length()-i);</span></span><br><span class="line"><span class="keyword"> </span>   right2=<span class="built_in">s2</span>.<span class="keyword">substring(0,s2.length()-i);</span></span><br><span class="line"><span class="keyword"> </span>   if(isScramble(left1,left2) &amp;&amp; isScramble(right1,right2)) return true<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return false<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态规划-三维数组"><a href="#动态规划-三维数组" class="headerlink" title="动态规划(三维数组)"></a>动态规划(三维数组)</h3><p>我们也能用动态规划来做,根据递归,我们能够发现,我们通过递归比较子树来确定是否是相等的.<br>由于是两个字符串的比较，还需要考虑交换的情况，所以我们需要三维数组来进行操作.<br><code>dp[i][j][len]</code>:<br>1.i:表示s1字符串需要比较的起始位置.<br>2.j:表示s2字符串需要比较的起始位置.<br>3.len:表示需要比较的长度.<br>4.所以我们得到了s1[i…i+len-1]与s2[j…j+len-1],我们需要比较这两个子字符串,那么我们需要进行分割.<br>我们把要分割的位置记为k,一共有k∈[1…len-1]的位置分法,根据上面递归的比较方法,我们判断:<br><code>s1[i...i+k-1]==s2[j...j+k-1] &amp;&amp; s1[i+k...i+len-k] || s1[i...i+k-1]==s2[j+len-k...j+len] &amp;&amp; s1[i+k...i+len]==s2[j...j+len-k]</code><br>也就是:<code>dp[i][j][k] &amp;&amp; dp[i+k][j+k][len-k] || dp[i+k][j][len-k] &amp;&amp; dp[i][j+len-k][k]</code></p><p>接下来我们确定len的范围,由于len&gt;k，所以len∈[2…s1.length()].i和j都∈[0…s1.length()-len].<br>以下是代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean isScramble(String s1,String s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()!=s2.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n=s1.length();</span><br><span class="line">    boolean[][][] dp=<span class="built_in">new</span> boolean[n][n][n+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//判断长度为1的时候是否相等</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">          dp[i][j][<span class="number">1</span>]=s1.charAt(i)==s2.charAt(j);  </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">len</span>=<span class="number">2</span>;<span class="built_in">len</span>&lt;=n;<span class="built_in">len</span>++)  <span class="comment">//长度从2开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-<span class="built_in">len</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n-<span class="built_in">len</span>;j++)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;<span class="built_in">len</span>;k++) <span class="comment">//分割位置遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k] &amp;&amp; dp[i+k][j+k][<span class="built_in">len</span>-k] || dp[i+k][j][<span class="built_in">len</span>-k] &amp;&amp; dp[i][j+<span class="built_in">len</span>-k][k])</span><br><span class="line">                       dp[i][j][<span class="built_in">len</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大矩形和</title>
      <link href="/dp_5/"/>
      <url>/dp_5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/30/AByn39.png" alt="AByn39.png"><br><a id="more"></a></p><h3 id="Given-a-2D-binary-matrix-filled-with-0’s-and-1’s-find-the-largest-rectangle-containing-only-1’s-and-return-its-area"><a href="#Given-a-2D-binary-matrix-filled-with-0’s-and-1’s-find-the-largest-rectangle-containing-only-1’s-and-return-its-area" class="headerlink" title="Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area."></a>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</h3><p>Example:</p><p>Input:<br>[<br>  [“1”,”0”,”1”,”0”,”0”],<br>  [“1”,”0”,”1”,”1”,”1”],<br>  [“1”,”1”,”1”,”1”,”1”],<br>  [“1”,”0”,”0”,”1”,”0”]<br>]<br>Output: 6</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个0和1的矩阵,求出只包含1的矩形的最大和.</p><p>具体方法来自<a href="https://www.cnblogs.com/grandyang/p/4322667.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4322667.html</a></p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈:"></a>堆栈:</h3><p>我们先来看它的子问题:<br><a href="https://imgchr.com/i/ABDfu6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/30/ABDfu6.png" alt="ABDfu6.png"></a></p><p>以上是柱状图,让你求出最大矩形的面积.<br>也是用堆栈来解(具体思路如下):<br>我们维护一个单调递增的栈<br>(<code>当我们的栈顶元素小于等于新元素时，我们将它加入栈.否则我们将栈顶元素出栈，直到栈顶元素小于新元素为止</code>)<br>我们拿height=(2,3,4,7,4,5,3)举例:<br>1.刚开始，栈为空(我们将2压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2   </th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0      </td></tr></tbody></table><p>2.遇到3,发现3&gt;2(我们将3压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>3.遇到4,发现4&gt;3(我们将4压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>4.遇到7,发现7&gt;4(我们将7压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><p>4.遇到4,发现4&lt;7(我们将4出栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4   </th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2  </td></tr></tbody></table><p>5.发现4&lt;=4(我们将4压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr></tbody></table><p>6.遇到5,4&lt;5(5压栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>7.遇到3,发现3&lt;5(5出栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr></tbody></table><p>8.发现栈顶元素4&gt;3(4出栈):</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4   </th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2   </td></tr></tbody></table><p>9.4继续出栈,发现栈顶3&lt;=3，3入栈:</p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">index</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">6</td></tr></tbody></table><p>以上就是维护单调栈的过程，那么我们如何利用单调栈来求最大矩形面积呢?<code>碰到出栈情况时,将即将出栈元素的值*(即将入栈元素的位置-栈顶元素的位置-1)，就是矩形的面积</code>,由于不遇到出栈情况时，我们不更新面积最大值,我们需要再最后手动加个值为0的元素，保证每个矩形的面积都计算到.   </p><p>以下是具体代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> getArea(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span>[] heights=Arrays.copyOf(<span class="built_in">height</span>,<span class="built_in">height</span>.length+<span class="number">1</span>); <span class="comment">//在数组的最后添加一个元素0,保证所有值都能出栈</span></span><br><span class="line">     Stack&lt;Integer&gt; st=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>; <span class="comment">//记录面积的最大值</span></span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">if</span>(st.empty() || heights[st.<span class="built_in">peek</span>()]&lt;=heights[i]) st.push(i); <span class="comment">//栈顶元素小于新元素，入栈(注意,栈记录元素的位置).</span></span><br><span class="line">         <span class="built_in">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">int</span> top=st.pop();</span><br><span class="line">             <span class="built_in">max</span>=Math.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="built_in">height</span>[top]*(st.empty()?i:(i-st.<span class="built_in">peek</span>()<span class="number">-1</span>)));  <span class="comment">//更新最大值,i-st.peek()-1为矩形的长</span></span><br><span class="line">             i--;  <span class="comment">//继续将该元素作为新元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>知道了子问题的解法,主问题也类似:<br>拿矩阵:<br>[<br>  [“1”,”0”,”1”,”0”,”0”],<br>  [“1”,”0”,”1”,”1”,”1”],<br>  [“1”,”1”,”1”,”1”,”1”],<br>  [“1”,”0”,”0”,”1”,”0”]<br>]举例.</p><p>我们分割来看:<br>第一行可以看成:height=(1,0,1,0,0)<br>第1-2行可以看成:height=(2,0,2,1,1)<br>第1-3行可以看成:height=(3,1,3,2,2)<br>第1-4行可以看成:height=(4,0,0,3,0)<br>那么我们只需要对每一行求最大矩形的面积即可:<br>以下是代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maximalRectangle(<span class="keyword">char</span>[][] matrix) &#123;</span><br><span class="line">     <span class="built_in">if</span>(matrix.length==<span class="number">0</span>) <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] <span class="built_in">height</span>=<span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length+<span class="number">1</span>];  <span class="comment">//在尾部加0，保证所有元素出栈</span></span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">height</span>[j]=(matrix[i][j]==<span class="string">'0'</span>)?<span class="number">0</span>:(<span class="built_in">height</span>[j]+<span class="number">1</span>);  <span class="comment">//遇到1，更新高度，否则置为0</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">max</span>=Math.<span class="built_in">max</span>(<span class="built_in">max</span>, getArea(<span class="built_in">height</span>));  <span class="comment">//对遍历到的每个柱状图，求最大矩形的面积</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> <span class="built_in">max</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> getArea(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     Stack&lt;Integer&gt; st=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">height</span>.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">if</span>(st.empty() || <span class="built_in">height</span>[st.<span class="built_in">peek</span>()]&lt;=<span class="built_in">height</span>[i]) st.push(i);</span><br><span class="line">     <span class="built_in">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">int</span> top=st.pop();</span><br><span class="line">     <span class="built_in">max</span>=Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="built_in">height</span>[top]*(st.empty()?i:i-st.<span class="built_in">peek</span>()<span class="number">-1</span>));</span><br><span class="line">     i--;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们还能用三个数组left[],right[],height[].<br>1.height:<br>用来记录到这行为止,每个位置的高度最大值<br>2.left:<br>用来记录到这个位置为止,1出现的最左端位置.<br>3.right:<br>用来记录到这个位置位置,1出现的最右端位置.</p><p>我们继续拿<br>[<br>[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]<br>]举例:<br>1.</p><table><thead><tr><th style="text-align:center">‘’</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">0  </th></tr></thead><tbody><tr><td style="text-align:center">height</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr></tbody></table><p>2.</p><table><thead><tr><th style="text-align:center">‘’</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">0  </th></tr></thead><tbody><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr></tbody></table><p>3.</p><table><thead><tr><th style="text-align:center">‘’</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">0  </th></tr></thead><tbody><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>4.</p><table><thead><tr><th style="text-align:center">‘’</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">0  </th></tr></thead><tbody><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">  ‘’</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>最后我们只需求(right-left)*height的最大值即可</p><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.<span class="built_in">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     int res=<span class="number">0</span>,m=matrix.<span class="built_in">length</span>,n=matrix[<span class="number">0</span>].<span class="built_in">length</span>;</span><br><span class="line">     int[] height=new int[n];</span><br><span class="line">     int[] left=new int[n];</span><br><span class="line">     int[] right=new int[n];</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++) right[<span class="built_in">i</span>]=n;</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;m;<span class="built_in">i</span>++)</span><br><span class="line">     &#123;</span><br><span class="line">     int cur_left=<span class="number">0</span>,cur_right=n;</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">if</span>(matrix[<span class="built_in">i</span>][<span class="built_in">j</span>]==<span class="string">'1'</span>) height[<span class="built_in">j</span>]++;</span><br><span class="line">     <span class="keyword">else</span> height[<span class="built_in">j</span>]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">if</span>(matrix[<span class="built_in">i</span>][<span class="built_in">j</span>]==<span class="string">'1'</span>) left[<span class="built_in">j</span>]=Math.<span class="built_in">max</span>(left[<span class="built_in">j</span>],cur_left);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     left[<span class="built_in">j</span>]=<span class="number">0</span>;</span><br><span class="line">     cur_left=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">j</span>=n<span class="number">-1</span>;<span class="built_in">j</span>&gt;=<span class="number">0</span>;<span class="built_in">j</span>--)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">if</span>(matrix[<span class="built_in">i</span>][<span class="built_in">j</span>]==<span class="string">'1'</span>) right[<span class="built_in">j</span>]=Math.<span class="built_in">min</span>(right[<span class="built_in">j</span>], cur_right);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     right[<span class="built_in">j</span>]=n;</span><br><span class="line">     cur_right=<span class="built_in">j</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">     &#123;</span><br><span class="line">     res=Math.<span class="built_in">max</span>(res,(right[<span class="built_in">j</span>]-left[<span class="built_in">j</span>])*height[<span class="built_in">j</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑距离</title>
      <link href="/dp_4/"/>
      <url>/dp_4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/29/ABVgl6.png" alt="ABVgl6.png"><br><a id="more"></a></p><h3 id="Given-two-words-word1-and-word2-find-the-minimum-number-of-operations-required-to-convert-word1-to-word2"><a href="#Given-two-words-word1-and-word2-find-the-minimum-number-of-operations-required-to-convert-word1-to-word2" class="headerlink" title="Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2."></a>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</h3><p>You have the following 3 operations permitted on a word:</p><p>  1.Insert a character<br>  2.Delete a character<br>  3.Replace a character</p><p>Example 1:</p><p>Input: word1 = “horse”, word2 = “ros”<br>Output: 3<br>Explanation:<br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)</p><p>Example 2:</p><p>Input: word1 = “intention”, word2 = “execution”<br>Output: 5<br>Explanation:<br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你两个字符串word1,word2.word1需要根据最少的操作来转换成word2,一共有3种操作:<br>1.replace:将字符串中某个字符转换成另一个字符.<br>2.remove:将字符串中某个字符移除.\<br>3.insert:将一个字符插入到字符串的任意位置.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><p>我们定义dp[i][j]来代表word1[0…j]转变成word2[0…i]需要的最少操作.<br>接下来就是找出关系式:<br>先来考虑三种操作如何表示:<br>1.替换:假设word1[0…i-1]与word2[0…j-1]已完成最少转换操作,并且word1[i]!=word2[j],那么我们将word1[i]替换成word[j],也就是dp[i-1][j-1]+1.<br>2.删除:假设word1[0…i-1]与word2[0…j]已完成最少转换操作,那么我们将word1[i]删除后使得它们仍然相等,也就是dp[i-1][j]+1.<br>3.插入:假设word1[0…i]与word2[0…j-1]已完成最少转换操作,那么我们将word1[i]中插入一个元素使得它们仍然相等,也就是dp[i][j-1]+1.</p><p>然后再考虑两种情况:<br>1.word1[i]==word2[j]:<br>那么需要取三种操作后的最小值(其中不需要替换操作):<br>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j]+1,dp[i][j-1]+1)<br>2.word1[i]!=word2[j]:<br>也是取三种操作的最小值:<br>dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1)</p><p>结合例子理解:</p><table><thead><tr><th style="text-align:center">word2\word1</th><th style="text-align:center">h</th><th style="text-align:center">o</th><th style="text-align:center">r</th><th style="text-align:center">s</th><th style="text-align:center">e  </th></tr></thead><tbody><tr><td style="text-align:center"> r</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4  </td></tr><tr><td style="text-align:center"> o</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4  </td></tr><tr><td style="text-align:center"> s</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">3  </td></tr></tbody></table><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1,String word2)</span><br><span class="line">&#123;</span><br><span class="line">      int m=word1.<span class="built_in">length</span>();</span><br><span class="line">      int n=word2.<span class="built_in">length</span>();</span><br><span class="line">      int[][] dp=new int[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++) dp[<span class="number">0</span>][<span class="built_in">i</span>]=<span class="built_in">i</span>;</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++) dp[<span class="built_in">i</span>][<span class="number">0</span>]=<span class="built_in">i</span>;</span><br><span class="line">      <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(word1.charAt(<span class="built_in">i</span><span class="number">-1</span>)==word2.charAt(<span class="built_in">j</span><span class="number">-1</span>))</span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>],Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]+<span class="number">1</span>,dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>,Math.<span class="built_in">min</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]+<span class="number">1</span>,dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符匹配</title>
      <link href="/dp_3/"/>
      <url>/dp_3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/29/ABFFC6.png" alt="ABFFC6.png"><br><a id="more"></a></p><h3 id="Given-an-input-string-s-and-a-pattern-p-implement-wildcard-pattern-matching-with-support-for-‘-’-and-‘-’"><a href="#Given-an-input-string-s-and-a-pattern-p-implement-wildcard-pattern-matching-with-support-for-‘-’-and-‘-’" class="headerlink" title="Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’."></a>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</h3><p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).</p><p>The matching should cover the entire input string (not partial).</p><p>Note:</p><pre><code>s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like ? or *.</code></pre><p>Example 1:</p><p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p><p>Example 2:</p><p>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.</p><p>Example 3:</p><p>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.</p><p>Example 4:</p><p>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.</p><p>Example 5:</p><p>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析:"></a>题意分析:</h2><p>与前一道<a href="http://blog.kamike.cn/dp_1/">表达式匹配</a>类似，不过比那道要简单.<br>给你两个字符串s和p,要求s和P能够匹配,‘？’表示能与任何字符匹配,’*’表示一个任何的序列，包括空序列.<br>我们还是用动态规划来做.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们定义dp[i][j]为p的区间[0,i]与s的区间[0,j]是否匹配.<br>我们有两种情况:<br>1.dp[i][j]=dp[i-1][j] || (j&gt;0 &amp;&amp; dp[i][j-1]) || i==1,如果p[i-1]==’<em>‘.我们假设p[0…i-1]与s[0…j]已正确匹配,那么’</em>‘就代表空序列使得p[0…i]与s[0…j]继续匹配，我们又假设p[0…i]与s[0…j-1]已匹配,那么’*’继续延长序列使得p[0…i]与s[0…j]继续匹配.<br>2.dp[i][j]=(j&gt;0 &amp;&amp; dp[i-1][j-1] &amp;&amp; (p.charAt(i-1)==s.charAt(j-1) || p.charAt(i-1)==’?’)),如果p[i-1]==s[j-1]或p[i-1]==’?’.我们假设p[0…i-1]与s[0…j-1]已正确匹配,那么p[0…i]与s[0…j]匹配的充要条件就是p[i]=s[j].</p><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s,String p)</span><br><span class="line">&#123;</span><br><span class="line">    int m=p.<span class="built_in">length</span>();</span><br><span class="line">    int n=s.<span class="built_in">length</span>();</span><br><span class="line">    int[][] dp=new int[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>] || (<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]) || <span class="built_in">i</span>==<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=(<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (p.chaAt(<span class="built_in">i</span><span class="number">-1</span>)==s.charAt(<span class="built_in">j</span><span class="number">-1</span>) || p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'?'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长合法括号</title>
      <link href="/dp_2/"/>
      <url>/dp_2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/28/AwB7Sx.png" alt="AwB7Sx.png"><br><a id="more"></a></p><h3 id="Given-a-string-containing-just-the-characters-‘-‘-and-‘-’-find-the-length-of-the-longest-valid-well-formed-parentheses-substring"><a href="#Given-a-string-containing-just-the-characters-‘-‘-and-‘-’-find-the-length-of-the-longest-valid-well-formed-parentheses-substring" class="headerlink" title="Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring."></a>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</h3><p>Example 1:</p><p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”</p><p>Example 2:</p><p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个字符串s，返回它最长合法括号的长度。</p><p>(具体方法来自<a href="https://leetcode.com/problems/longest-valid-parentheses/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-valid-parentheses/solution/</a>)</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们用dp[i]来表示区间[0,i]中最长合法括号的长度.</p><p>接下来我们还是找出递推关系式：<br>1.dp[i]=dp[i-2]+2,如果s.charAt(i)==’)’ &amp;&amp; s.charAt(i-1)==’(‘.<br>这个很好理解，我们已经得到了dp[i-2]的值，表明区间[0,i-2]的合法括号长度，我们根据s[i-1]==’(‘和s[i]==’)’又得到一对括号，所以我们在dp[i-2]的基础上加上2.<br>2.dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2,如果s.charAt(i)==’)’ &amp;&amp; s.charAt(i-dp[i-1]-1)==’(‘.<br>现在我们得到了s[i-dp[i-1]-1]==’(‘与s[i]==’)’匹配，所以我们在dp[i-1]的长度基础上加上2,但此时[i-dp[i-1]-1,i]已经完全匹配，我们还要考虑与[0,i-dp[i-1]-2]的已经合法的长度对接，固还要加上dp[i-dp[i-1]-2].</p><p>以下是代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> longestValidParentheses(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">     <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">if</span>(s.charAt(i)==<span class="string">')'</span> &amp;&amp; s.charAt(i<span class="number">-1</span>)==<span class="string">'('</span>)  <span class="comment">//第一种情况</span></span><br><span class="line">         &#123;</span><br><span class="line">             dp[i]=(i&gt;=<span class="number">2</span>?dp[i<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;   <span class="comment">//注意i-2&gt;=0.</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i)==<span class="string">')'</span> &amp;&amp; s.charAt(i-dp[i<span class="number">-1</span>]<span class="number">-1</span>)==<span class="string">'('</span>) <span class="comment">//第二种情况,i-dp[i-1]-1&gt;=0</span></span><br><span class="line">         &#123;</span><br><span class="line">             dp[i]=dp[i<span class="number">-1</span>]+(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>? dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;  <span class="comment">//i-dp[i-1]-2&gt;=0</span></span><br><span class="line">         &#125;</span><br><span class="line">         maxlen=Math.<span class="built_in">max</span>(maxlen,d[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合例子理解:</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">)</td><td style="text-align:center">)</td><td style="text-align:center">(</td><td style="text-align:center">(</td><td style="text-align:center">(</td><td style="text-align:center">)</td><td style="text-align:center">)  </td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">4  </td></tr></tbody></table><h3 id="两变量写法"><a href="#两变量写法" class="headerlink" title="两变量写法"></a>两变量写法</h3><p>我们用两个变量来维护，left和right，left表示匹配的’(‘个数，right表示匹配的’)’个数.<br>1.我们将left和right初始化0,从数组开头开始遍历:<br>(1).当遇到’(‘我们把left加一，遇到’)’我们把right加一.<br>(2).当left==right的时候，说明left数量与right数量已正确匹配，更新最大值为2<em>right.<br>(3).当right&gt;left，说明右括号数量比左括号多不匹配，我们把left和right都清0.<br>2.我们将left和right初始化为0，从数组末端开始遍历:<br>(1).同样当遇到’(‘我们把left加一，遇到’)’我们把right加一.<br>(2).当left==right的时候，说明left数量与right数量已正确匹配，更新最大值为2</em>left.<br>(3).当left&gt;right，说明左括号数量比右括号多,不匹配，我们把left和right都清0.<br>我们证明1.(3)和2.(3):<br>1.(3):<br>当left&gt;right，说明’(‘数量比’)’多，如果继续往右扩展我们还能碰到’)’,即能扩展合法空间,所以我们继续遍历.<br>当left&lt;right, 说明’)’数量比’(‘多, 那么我们遍历到的最后一个字符便是’)’,那么继续往右遍历我们会得到’)(‘或’))’,两者都无法使区间正确的扩展,所以我们把left和right清0.<br>2.(3):<br>同理当right&gt;left,因为是向左扩展,对于多出来的’)’,往左扩展我们还能碰到’(‘匹配.<br>当right&lt;left,那么我们遍历到的最后一个字符便是’(‘,那么继续往右遍历我们会得到’)(‘或’((‘，则不再有效，固left=right=0.</p><p>以下是代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int longestValidParentheses(<span class="type">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">max</span>=<span class="number">0</span>,<span class="keyword">left</span>=<span class="number">0</span>,<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)=='(') <span class="keyword">left</span>++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">right</span>++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span>==<span class="keyword">right</span>) <span class="built_in">max</span>=<span class="type">Math</span>.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="keyword">right</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span>) <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==')') <span class="keyword">right</span>++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">left</span>++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span>==<span class="keyword">right</span>) <span class="built_in">max</span>=<span class="type">Math</span>.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="keyword">left</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>) <span class="keyword">left</span>=<span class="keyword">right</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆栈写法"><a href="#堆栈写法" class="headerlink" title="堆栈写法"></a>堆栈写法</h3><p>我们还可以使用堆栈来写,每当我们遇到’(‘,我们把它的位置压栈,当遇到’)’,我们弹出栈顶元素,当栈顶不为空时我们更新长度,为空时我们把该位置压入栈.(思路与括号匹配类似，遇到右括号把左括号弹出，因为这边要记录长度，所以我们存储位置)</p><p>以下是代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; st=new Stack&lt;&gt;();</span><br><span class="line">    st.push(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;s.<span class="built_in">length</span>();<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="built_in">i</span>)==<span class="string">'('</span>)</span><br><span class="line">          st.push(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(<span class="built_in">i</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span>=Math.<span class="built_in">max</span>(<span class="built_in">max</span>,<span class="built_in">i</span>-st.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式匹配</title>
      <link href="/dp_1/"/>
      <url>/dp_1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/27/Aa26Mt.png" alt="Aa26Mt.png"><br><a id="more"></a></p><h3 id="Given-an-input-string-s-and-a-pattern-p-implement-regular-expression-matching-with-support-for-‘-’-and-‘-’"><a href="#Given-an-input-string-s-and-a-pattern-p-implement-regular-expression-matching-with-support-for-‘-’-and-‘-’" class="headerlink" title="Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’."></a>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</h3><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p><p>The matching should cover the entire input string (not partial).<br>Note:</p><pre><code>s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *.Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2:Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.Example 3:Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.Example 5:Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false</code></pre><hr><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你两个字符串s和p,要求p能与s匹配,’.’表示能与任何字符匹配,’<em>‘表示之前的字符能出现多次或着0次.注意’.’也能被重复,’.</em>‘能与任何字符串匹配.</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>由于不是位置对应的匹配相等，我们只好分别判断某一段是否匹配，然后在前面匹配的条件下，来判断后面是否匹配.<br>具体思路请看<a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/c-on-space-dp" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/discuss/5684/c-on-space-dp</a><br>我们定义dp[i][j]为p的区间[0,i]与s的区间[0,j]是否匹配.<br>我们有三种情况:<br>1.dp[i][j]=dp[i-1][j-1],如果p[i-1]!=’<em>‘ &amp;&amp; (s[j-1]==p[i-1] || p[i-1] == ‘.’) 因为’.’能匹配任何字符<br>2.dp[i][j]=dp[i-2][j],如果p[i-1]==’</em>‘  ，因为’<em>‘能使前字符重复0次<br>3.dp[i][j]=dp[i][j-1] &amp;&amp; (s[j-1]==p[i-2] || p[i-2] == ‘.’),如果p[i-1]==’</em>‘，因为’<em>‘能使前字符重复多次.<br>我们来看例子<br>s=”ab”<br>p=”c</em>.*b”</p><table><thead><tr><th style="text-align:center">p\s</th><th style="text-align:center">“”</th><th style="text-align:center">a</th><th>b</th></tr></thead><tbody><tr><td style="text-align:center"> “”</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> c</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> *</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td>0</td><td></td></tr><tr><td style="text-align:center"> .</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td>0</td><td></td></tr><tr><td style="text-align:center"> *</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td>0</td><td></td></tr><tr><td style="text-align:center"> b</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td>1</td><td></td></tr></tbody></table><p>由此关系式我们可以写出代码:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s,String p)</span><br><span class="line">&#123;</span><br><span class="line">    int m=p.<span class="built_in">length</span>();</span><br><span class="line">    int n=s.<span class="built_in">length</span>();</span><br><span class="line">    boolean[][] dp=new boolean[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=n;<span class="built_in">j</span>++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'*'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=dp[<span class="built_in">i</span><span class="number">-2</span>][<span class="built_in">j</span>] || (<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (s.charAt(<span class="built_in">j</span><span class="number">-1</span>)==p.charAt(<span class="built_in">i</span><span class="number">-2</span>)||p.charAt(<span class="built_in">i</span><span class="number">-2</span>)==<span class="string">'.'</span>));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               dp[<span class="built_in">i</span>][<span class="built_in">j</span>]=(<span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; dp[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span><span class="number">-1</span>] &amp;&amp; (s.charAt(<span class="built_in">j</span><span class="number">-1</span>)==p.charAt(<span class="built_in">i</span><span class="number">-1</span>) || p.charAt(<span class="built_in">i</span><span class="number">-1</span>)==<span class="string">'.'</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/dp/"/>
      <url>/dp/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/26/AN7dl4.png" alt="AN7dl4.png"><br><a id="more"></a></p><h3 id="Given-a-string-s-find-the-longest-palindromic-substring-in-s-You-may-assume-that-the-maximum-length-of-s-is-1000"><a href="#Given-a-string-s-find-the-longest-palindromic-substring-in-s-You-may-assume-that-the-maximum-length-of-s-is-1000" class="headerlink" title="Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000."></a>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</h3><hr><p>Example 1:<br><code>Input: &quot;babad&quot;</code><br><code>Output: &quot;bab&quot;</code><br><code>Note: &quot;aba&quot; is also a valid answer.</code><br>Example 2:<br><code>Input: &quot;cbbd&quot;</code><br><code>Output: &quot;bb&quot;</code></p><hr><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>给你一个字符串，返回它最长的回文子串(翻转后和自身相等的串)。</p><p>第一个能快速想到的方法就是暴力解法:</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法的核心思路就是枚举每一个字串，然后判断它是不是回文串，并记录它的长度，并更新长度的最大值.<br>以下是判断是不是回文串的代码,因为回文串关于<code>中心对称</code>，我们只要判断两边的字符是否相等，如果有不相等，直接判断为不是.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPalindrome(String s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)  <span class="comment">//len/2表示我们只要判断一半.</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(s.charAt(i)!=s.charAt(len-i<span class="number">-1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//遇到关于中心对称的两端不相等的，直接返回false；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//所有判断都通过，返回true;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是逐个枚举并调用以上<code>isPalindrome</code>函数.我们定义两个变量i,j;i表示枚举子串的左端点,j表示枚举子串的右端点.i∈[0,len),j∈[i,len).(i&lt;=j,左端点值小于右端点)<br>那么我们使用两个for循环来遍历区间位置:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindromicSubstring(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">String</span> res=<span class="string">""</span>; <span class="comment">//存储长度最大的回文串</span></span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">if</span>(isPalindrome(s.substring(i,j+<span class="number">1</span>))) <span class="comment">//substring方法区间取值是前闭后开，所以我们取[i,j+1).</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">if</span>(j+<span class="number">1</span>-i&gt;res.length()) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过三个循环，我们很容易得出时间复杂度是O(n^3),空间复杂度为O(1).</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>暴力解法的时间复杂度这么高，原因是遍历了每一种可能.那么其中就会有重复判断或者避免判断的子串.<br>动态规划的核心思想就是根据已有的条件，通过推导公式，推导出结果，那么我们就减少了很多重复的判断<br>比如说:<code>&quot;cabddbac&quot;中，我们用暴力解法时，&#39;abddba&#39;与&#39;bddb&#39;我们重复判断了&#39;d&#39;==&#39;d&#39;与&#39;b&#39;==&#39;b&#39;</code>.<br>那么我们如何避免重复判断呢?对于变动的左右断点形成的区间，我们定义一个<code>二维数组dp[len][len](len表示原字符串的长度).</code><br>我们用<code>dp[i][j]=1来表示区间[i,j]是回文串</code>.那么如何根据存储的条件，推出未知条件呢,<br>\begin{cases}<br>dp[i][j]=1, &amp;(i==j\or(j==i+1\and\s.charAt(j)==s.charAt(i)))<br>\end{cases}<br>\begin{cases}<br>dp[i][j]=dp[i+1][j-1], &amp;(s.charAt(j)==s.charAt(i)\and\j-i&gt;2)<br>\end{cases}<br>固我们根据该递推式来写出代码<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindromicSubstring(<span class="keyword">String</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(s.length()==<span class="number">0</span>) <span class="built_in">return</span> <span class="string">""</span>;   <span class="comment">//如果字符串s为空，则输出空字符串</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,maxlen=<span class="number">0</span>,len=s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">if</span>(i==j || (s.charAt(i)==s.charAt(j) &amp;&amp; i==j+<span class="number">1</span>))  <span class="comment">//两个条件的判断</span></span><br><span class="line">           &#123;</span><br><span class="line">              dp[j][i]=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">if</span>(i-j&gt;=<span class="number">2</span> &amp;&amp; s.charAt(i)==s.charAt(j))</span><br><span class="line">           &#123;</span><br><span class="line">              dp[j][i]=dp[j+<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">if</span>(dp[j][i]==<span class="number">1</span> &amp;&amp; maxlen&lt;i+<span class="number">1</span>-j)  <span class="comment">//记录最大区间</span></span><br><span class="line">           &#123;</span><br><span class="line">              left=j;</span><br><span class="line">              right=i+<span class="number">1</span>;</span><br><span class="line">              maxlen=i+<span class="number">1</span>-j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> s.substring(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容易看出时间和空间复杂度都是O(n^2)</p><h3 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h3><p>现在我们换种暴力解法的思路,我们以<code>字符串的一个字符为中心</code>，向两边不断<code>扩展</code>，以此来得到最长的回文串.<br>比如字符串”aba”:<br><code>1.取第一个字符&#39;a&#39;:两边无相同元素，无法继续扩展，所以长度为1.</code><br><code>2.取第二个字符&#39;b&#39;:两边都有相同元素&#39;a&#39;,所以我们扩展至长度为3,继续扩展，发现达到边界，无法扩展，所以此时最长为&#39;aba&#39;.</code><br><code>3.取第三个字符&#39;a&#39;:两边无相同元素，无法继续扩展，所以长度为1</code><br>固我们得到最长回文串为’aba’.<br>但我们会发现有个问题，那就是如果我们取偶数长度的字符串’abba’:我们会发现没有对称中心，所以这种方法是不是就不能适用这种情况了呢.</p><p>下面就是<code>马拉车算法</code>奇妙的地方了,我们首先对字符串做优先处理，在字符与字符之间<code>插入一个字符&#39;#&#39;</code>,我们就能保证字符串的长度就是<code>奇数个</code>了，比如说刚才我们举得例子<code>&#39;abba&#39;</code>，进行处理后我们得到<code>&#39;#a#b#b#a#&#39;</code>,那么我们就有了对称中心’#’，就能继续使用刚才的暴力解法了.我们设<code>len[i]的值为字符串以第i个字符为中心的最长回文半径</code>，<code>mx为最长回文子串的最后端点的位置</code>,<code>id为最长回文子串的对称中心点</code>.<br>我们就拿’#a#b#b#a#’举例:<br><code>1.第一个字符&#39;#&#39;:无法扩展，半径为1,此时mx更新为0,id为0</code><br><code>2.第二个字符&#39;a&#39;:能扩展到两边&#39;#&#39;，半径为2，此时mx更新为2，id为1</code><br><code>2.第三个字符&#39;#&#39;:无法扩展，半径为1,半径不是最大，不改变</code><br><code>3.第四个字符&#39;b&#39;:能扩展到两边&#39;#&#39;，半径为2，此时不更新</code><br><code>4.第五个字符&#39;#&#39;:能扩展到最两端的&#39;#&#39;，半径为5,此时更新mx为8,id为4</code><br><code>5.第六个字符&#39;b&#39;:我们发现此时i&lt;mx(6&lt;8)，我们发现此时中心&#39;b&#39;处在最大的回文子串之中,那么我们是不是还需要继续循环往外重复扩展呢.我们可以根据已知的最长回文子串&#39;#a#b#b#a#&#39;可知两边是对称的,所以右边的&#39;b&#39;与左边的&#39;b&#39;对称，那么半径就是从2开始扩展</code><br>后面相同的思想，略过<br>···</p><p>那么我们来看一般情况:<br>假设我们遍历到的对称中心<code>i&lt;mx</code>:<br>我用画图软件随便画了一下:<br><img src="https://s2.ax1x.com/2019/03/26/ANIjXR.png" alt="ANIjXR.png"><br>我们可以得到此时i与2<em>id-i是对称的，那么len[i]的起始半径要不就是<code>mx-i</code>,要么就是`len[2</em>id-i]`<br>那么我们取哪个呢，小的那个:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下我们用反证法来证明一下:</span><br><span class="line">假设len[<span class="number">2</span>*<span class="built_in">id</span>-i]&gt;mx-i,len[<span class="built_in">id</span>]=mx-i.</span><br><span class="line">我们有len[i]=len[<span class="number">2</span>*<span class="built_in">id</span>-i]</span><br><span class="line">那么我们继续以<span class="built_in">id</span>为对称中心,由于此时[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>,i]都是以<span class="built_in">id</span>为中心的回文串，又len[i]=len[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>],两者也关于<span class="built_in">id</span>对称，</span><br><span class="line">那么我们可以把<span class="built_in">id</span>为对称中心的半径扩展到len[<span class="built_in">id</span>]=len[<span class="number">2</span>*<span class="built_in">id</span><span class="number">-1</span>]+i-<span class="built_in">id</span>&gt;mx-i,这与假设len[<span class="built_in">id</span>]=mx-i矛盾,固我们取较小的那个</span><br></pre></td></tr></table></figure></p><p>那么我们还有另一种情况’i&gt;=mx’：<br>此时没有办法，只能老老实实向外扩展</p><p>以下是完整代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindromicSubstring(String s)</span><br><span class="line">&#123;</span><br><span class="line">   String str=<span class="string">"#"</span>;</span><br><span class="line">   <span class="keyword">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>,maxlen=<span class="number">0</span>,maxid=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] <span class="built_in">len</span>=<span class="built_in">new</span> <span class="keyword">int</span>[<span class="number">2</span>*s.length()+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">   &#123;</span><br><span class="line">     str+=s.charAt(i)+<span class="string">"#"</span>;   <span class="comment">//字符串之间插入'#'</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(i&lt;mx) <span class="built_in">len</span>[i]=Math.min(mx-i, <span class="built_in">len</span>[<span class="number">2</span>*id-i]);  <span class="comment">//第一种情况</span></span><br><span class="line">     while(i-<span class="built_in">len</span>[i]&gt;=<span class="number">0</span> &amp;&amp; i+<span class="built_in">len</span>[i]&lt;=str.length()<span class="number">-1</span> &amp;&amp; str.charAt(i-<span class="built_in">len</span>[i])==str.charAt(i+<span class="built_in">len</span>[i])) <span class="built_in">len</span>[i]++;</span><br><span class="line">     <span class="keyword">if</span>(mx&lt;<span class="built_in">len</span>[i]+i)  <span class="comment">//更新</span></span><br><span class="line">     &#123;</span><br><span class="line">       id=i;</span><br><span class="line">       mx=<span class="built_in">len</span>[i]+i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(maxlen&lt;<span class="built_in">len</span>[i]) <span class="comment">//更新最大长度</span></span><br><span class="line">     &#123;</span><br><span class="line">       maxlen=<span class="built_in">len</span>[i];</span><br><span class="line">       maxid=i;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.substring((maxid-maxlen+<span class="number">1</span>)/<span class="number">2</span>,(maxid+maxlen)/<span class="number">2</span>);  <span class="comment">//返回最大回文串的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度和空间复杂度均为O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结java反射(二)</title>
      <link href="/reflect2/"/>
      <url>/reflect2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/23/AGMjBR.jpg" alt="AGMjBR.jpg"><br><a id="more"></a></p><h1 id="分析类能力"><a href="#分析类能力" class="headerlink" title="分析类能力:"></a>分析类能力:</h1><p>在上一章简略(十分简略)的介绍了反射的机制,那么这一节我们具体介绍反射机制的重要内容—-<code>检查类的结构</code>.</p><hr><p>要了解java中类的结构，我们都知道类包括三个结构:<code>Field(数据域:常量，全局变量),Method(类方法),Constructor(类构造器)</code>.</p><p>好的，我们偷懒复制上一节的🗡类来做个例子:</p><hr><p>以下是🗡的数据域：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">//🗡的等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> durability;  <span class="comment">//🗡的耐久度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> attack;  <span class="comment">//🗡的攻击力</span></span><br></pre></td></tr></table></figure></p><hr><p>以下是🗡的类方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123; <span class="comment">//获取等级</span></span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDurability</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取耐久度</span></span><br><span class="line">  <span class="keyword">return</span> durability;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttack</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取攻击力</span></span><br><span class="line">  <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strenthen</span><span class="params">()</span> </span>&#123;  <span class="comment">//强化🗡的等级</span></span><br><span class="line">  <span class="keyword">int</span> random=(<span class="keyword">int</span>) (Math.random()+<span class="number">1</span>);</span><br><span class="line">  level+=random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以下是🗡的构造器:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sword()&#123;</span><br><span class="line">  <span class="keyword">this</span>.level=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.durability=<span class="number">150</span>;</span><br><span class="line">  <span class="keyword">this</span>.attack=<span class="number">150</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>那么我们如何用反射机制来获得🗡类的结构呢?</p><h2 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包:"></a>reflect包:</h2><p>在java.lang.reflect包中有三个类Field,Method和Constructor分别用于描述类的域，方法和构造器.<br>具体来看它们之间的关系:<br><a href="https://imgchr.com/i/AGMl01" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/23/AGMl01.md.png" alt="AGMl01.md.png"></a><br>可以看到Field,Method,Constructor都继承AccesibleObject类，并实现Number接口。</p><p>首先我们来看它们的共同父类<code>AccessibleObject</code>类:</p><h3 id="AccessibleObject类"><a href="#AccessibleObject类" class="headerlink" title="AccessibleObject类:"></a><em>AccessibleObject类</em>:</h3><p>它有最常用且核心的三个方法:<br>1.<code>void setAccesible(boolean flag)</code><br>为反射的对象设置可访问标志.flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置.<br>也就是说可以篡改🗡的等级和耐久度了(如此病态)<br>2.<code>boolean isAccessible()</code><br>返回反射对象的可访问标志的值.是private就返回false,是public就返回true.<br>3.<code>static void setAccesible(AccessibleObject[] array,boolean flag)</code><br>这个就更狠了，静态方法，能够快捷地对对象数组设置可访问标志</p><hr><p>简单了解了AccessibleObject类后，我们来看它们都实现的接口:Number.</p><h3 id="Number接口"><a href="#Number接口" class="headerlink" title="Number接口:"></a><em>Number接口</em>:</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> Member&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *表明一个类或接口中所有公共成员的集合</span></span><br><span class="line"><span class="comment">    *包括继承(派生)的成员</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PUBLIC</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *表明一个类或接口中声明成员的集合</span></span><br><span class="line"><span class="comment">    *不包括继承(派生)的成员</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DECLARED = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回实现了该接口的类或接口的Class类对象(参考第一节所提到的Class类)</span></span><br><span class="line"><span class="comment">     * 并声明成员或构造器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; getDeclaringClass();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回实现该接口的成员或构造器的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> String getName();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Java语言中对成员或构造器的解析值(int常量).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getModifiers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码摘抄自JavaSE-10的源码.<br>我们着重看<code>getModifiers()</code>这个方法，它返回一个类或接口的解析int值，那它具体代表什么呢?<br>这里就不得不要提到一个解析类<code>Modifier</code>:</p><h3 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类:"></a><em>Modifier类</em>:</h3><p>首先看Modifier类中的常量部分<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PUBLIC</span>       = <span class="number">0</span>x00000001;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PRIVATE</span>      = <span class="number">0</span>x00000002;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">PROTECTED</span>    = <span class="number">0</span>x00000004;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">STATIC</span>       = <span class="number">0</span>x00000008;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">FINAL</span>        = <span class="number">0</span>x00000010;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">SYNCHRONIZED</span> = <span class="number">0</span>x00000020;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">VOLATILE</span>     = <span class="number">0</span>x00000040;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">TRANSIENT</span>    = <span class="number">0</span>x00000080;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">NATIVE</span>       = <span class="number">0</span>x00000100;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">INTERFACE</span>    = <span class="number">0</span>x00000200;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">ABSTRACT</span>     = <span class="number">0</span>x00000400;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRICT       = <span class="number">0</span>x00000800;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BRIDGE    = <span class="number">0</span>x00000040;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VARARGS   = <span class="number">0</span>x00000080;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0</span>x00001000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION  = <span class="number">0</span>x00002000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0</span>x00004000;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANDATED  = <span class="number">0</span>x00008000;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASS_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.<span class="keyword">FINAL</span>   |</span><br><span class="line">        Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERFACE_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTRUCTOR_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> METHOD_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">ABSTRACT</span>       | Modifier.<span class="keyword">STATIC</span>       | Modifier.<span class="keyword">FINAL</span>   |</span><br><span class="line">        Modifier.<span class="keyword">SYNCHRONIZED</span>   | Modifier.<span class="keyword">NATIVE</span>       | Modifier.STRICT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIELD_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span>         | Modifier.<span class="keyword">PROTECTED</span>    | Modifier.<span class="keyword">PRIVATE</span> |</span><br><span class="line">        Modifier.<span class="keyword">STATIC</span>         | Modifier.<span class="keyword">FINAL</span>        | Modifier.<span class="keyword">TRANSIENT</span> |</span><br><span class="line">        Modifier.<span class="keyword">VOLATILE</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARAMETER_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">FINAL</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACCESS_MODIFIERS =</span><br><span class="line">        Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">PROTECTED</span> | Modifier.<span class="keyword">PRIVATE</span>;</span><br></pre></td></tr></table></figure></p><p>可以看出每一个类型都有对应的16进制int值对应,并通过:<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPublic(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PUBLIC) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrivate(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PRIVATE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isProtected(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; PROTECTED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isStatic(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; STATIC) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isFinal(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; FINAL) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isSynchronized(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; SYNCHRONIZED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isVolatile(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; VOLATILE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isTransient(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isNative(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; NATIVE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isInterface(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; INTERFACE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isAbstract(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; ABSTRACT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isStrict(<span class="keyword">int</span> <span class="keyword">mod</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mod</span> &amp; STRICT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>一系列判断的静态方法，来确定类型(返回值,类,接口,常量类型).<br>最后通过toString()方法打印:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static String toString(int mod) &#123;</span><br><span class="line">        StringJoiner sj = new StringJoiner(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PUBLIC) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"public"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PROTECTED) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"protected"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; PRIVATE) != 0)       sj.<span class="builtin-name">add</span>(<span class="string">"private"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; ABSTRACT) != 0)      sj.<span class="builtin-name">add</span>(<span class="string">"abstract"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; STATIC) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"static"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; FINAL) != 0)         sj.<span class="builtin-name">add</span>(<span class="string">"final"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; TRANSIENT) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"transient"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; VOLATILE) != 0)      sj.<span class="builtin-name">add</span>(<span class="string">"volatile"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; SYNCHRONIZED) != 0)  sj.<span class="builtin-name">add</span>(<span class="string">"synchronized"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; NATIVE) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"native"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; STRICT) != 0)        sj.<span class="builtin-name">add</span>(<span class="string">"strictfp"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mod &amp; INTERFACE) != 0)     sj.<span class="builtin-name">add</span>(<span class="string">"interface"</span>);</span><br><span class="line"></span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类:"></a><em>Field类</em>:</h3><p><code>Field[] getFields()</code><br><code>Field[] getDeclaredFields()</code><br>getFields方法返回一个包含Field对象的数组，记录这个类或其超类的公有域。getDeclaredFields方法也返回包含Fields对象的数组，记录这个类的全部域。如果没有数据域，则将返回一个长度为0的数组。<br><code>Class getType()</code><br>返回数据域对应类型的Class类<br>下面我们通过这些方法来获得🗡类的数据域</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> Sword s=new Sword();</span><br><span class="line"> <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line"> String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());  <span class="comment">//通过解析器获得cl的访问类型.</span></span><br><span class="line"> <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName()); <span class="comment">//输出🗡类名字</span></span><br><span class="line"> System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line"> printFields(<span class="keyword">cl</span>);  <span class="comment">//打印🗡类的数据域</span></span><br><span class="line"> System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public static void printFields(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line"> Field[] fields=<span class="keyword">cl</span>.getDeclaredFields();  <span class="comment">//获得🗡类的全部数据域</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(Field f:fields)  <span class="comment">//遍历每个数据</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">Class</span> <span class="keyword">type</span>=f.getType();  <span class="comment">//获得数据类型的Class对象</span></span><br><span class="line">  String name=f.getName();  <span class="comment">//获取数据的名字</span></span><br><span class="line">  System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);  </span><br><span class="line">  String modifiers=Modifier.<span class="keyword">toString</span>(f.getModifiers()); <span class="comment">//通过解析器获得cl的访问类型</span></span><br><span class="line">  <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span>);</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="keyword">type</span>.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>); <span class="comment">//输出对应类型和名字</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是输出结果<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> <span class="keyword"> public</span> core.Sword</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="built_in"> int </span>level;</span><br><span class="line">   <span class="keyword"> private</span><span class="built_in"> int </span>durability;</span><br><span class="line">   <span class="built_in"> int </span>attack;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类:"></a><em>Method类</em>:</h3><p>同样<br><code>Method[] getMethods()</code><br><code>Method[] getDeclaredMethods()</code><br>返回包含Method对象的数组：getMethods返回所有公有方法,包括从超类继承来的公有方法;getDeclaredMethods返回这个类或接口的全部方法，但不包括由超类继承来的方法<br><code>Class getReturnType()</code><br>描述方法返回类型的Class对象<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Sword s=new Sword(10,150,10);</span><br><span class="line">    <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line">    String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());</span><br><span class="line">    <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName());</span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">    <span class="comment">//printFields(cl);</span></span><br><span class="line">    printMethods(<span class="keyword">cl</span>); <span class="comment">//打印方法</span></span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public static void printMethods(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line">Method[] methods=<span class="keyword">cl</span>.getDeclaredMethods(); <span class="comment">//获得所有声明的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Method <span class="keyword">m</span>:methods)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Class</span> retType=<span class="keyword">m</span>.getReturnType(); <span class="comment">//获得方法的返回值类型</span></span><br><span class="line">String name=<span class="keyword">m</span>.getName();  <span class="comment">//获取方法名</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);</span><br><span class="line">String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">m</span>.getModifiers()); <span class="comment">//获取访问权限</span></span><br><span class="line"><span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers+<span class="string">" "</span>);  <span class="comment">//打印访问权限</span></span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(retType.getName() + <span class="string">" "</span> +name + <span class="string">"("</span>);  <span class="comment">//打印方法名和返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span>[] paramTypes = <span class="keyword">m</span>.getParameterTypes();  <span class="comment">//取得方法的参数</span></span><br><span class="line"><span class="keyword">for</span>(int j=0;j&lt;paramTypes.length;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">", "</span>);</span><br><span class="line">System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName()); <span class="comment">//打印参数</span></span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  <span class="comment">//public core.Sword</span></span><br><span class="line">  <span class="comment">//&#123;</span></span><br><span class="line">      <span class="comment">//public int getAttack();</span></span><br><span class="line">      <span class="comment">//public void strenthen();</span></span><br><span class="line">      <span class="comment">//public int getDurability();</span></span><br><span class="line">      <span class="comment">//public int getLevel();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类:"></a><em>Constructor类</em>:</h3><p><code>Constructor[] getConstructors()</code><br><code>Constructor[] getDeclaredConstructors()</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] <span class="keyword">args</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Sword s=new Sword(10,150,10);</span><br><span class="line">    <span class="keyword">Class</span> <span class="keyword">cl</span>=s.getClass();</span><br><span class="line">    String modifiers=Modifier.<span class="keyword">toString</span>(<span class="keyword">cl</span>.getModifiers());</span><br><span class="line">    <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span> + <span class="keyword">cl</span>.getName());</span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">    <span class="comment">//printFields(cl);</span></span><br><span class="line">    <span class="comment">//printMethods(cl);</span></span><br><span class="line">      printConstructors(<span class="keyword">cl</span>);  <span class="comment">//打印构造器</span></span><br><span class="line">    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">public static void printConstructors(<span class="keyword">Class</span> <span class="keyword">cl</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Constructor[] constructors=<span class="keyword">cl</span>.getDeclaredConstructors(); <span class="comment">//获取所有声明的构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Constructor c:constructors)</span><br><span class="line">    &#123;</span><br><span class="line">        String name=c.getName(); <span class="comment">//取得构造器名字</span></span><br><span class="line">        System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"    "</span>);</span><br><span class="line">            String modifiers=Modifier.<span class="keyword">toString</span>(c.getModifiers());  <span class="comment">//获取访问权限</span></span><br><span class="line">            <span class="keyword">if</span>(modifiers.<span class="built_in">length</span>()&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers+<span class="string">" "</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] paramTypes=c.getParameterTypes(); <span class="comment">//获取参数</span></span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;paramTypes.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;0) System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">","</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName());  <span class="comment">//打印参数名</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//public core.Sword</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//public core.Sword(int,int,int);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><hr><p>以上是反射三个包的具体应用<br>下一章我们使用反射改写数组的复制代码.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结java反射(一)</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/17/Ae4vG9.jpg" alt="古明地觉"><br><a id="more"></a></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射:"></a><strong>反射</strong>:</h1><p>反射库是java中能够动态的操纵java代码的程序，这种能分析类能力的程序被称为反射(reflective).<br>那么反射具体有哪些反射机制呢？</p><p>首先来说Class类</p><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>在程序运行期间，有着记录对象所属的类的信息的类，那就是Class类。</p><hr><h3 id="四个重要方法"><a href="#四个重要方法" class="headerlink" title="四个重要方法:"></a>四个重要方法:</h3><p>Object类中有一个方法<code>getClass()</code> ，它能返回Class类型的实例：<br>现在让我们来创建一个简单的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">//🗡的等级</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> durability;  <span class="comment">//🗡的耐久度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> attack;  <span class="comment">//🗡的攻击力</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.level=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">this</span>.durability=<span class="number">150</span>;</span><br><span class="line">     <span class="keyword">this</span>.attack=<span class="number">150</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123; <span class="comment">//获取等级</span></span><br><span class="line">     <span class="keyword">return</span> level;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDurability</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取耐久度</span></span><br><span class="line">     <span class="keyword">return</span> durability;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttack</span><span class="params">()</span> </span>&#123;  <span class="comment">//获取攻击力</span></span><br><span class="line">     <span class="keyword">return</span> attack;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strenthen</span><span class="params">()</span> </span>&#123;  <span class="comment">//强化🗡的等级</span></span><br><span class="line">     <span class="keyword">int</span> random=(<span class="keyword">int</span>) (Math.random()+<span class="number">1</span>);</span><br><span class="line">     level+=random;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们简单的建完了我们的<code>🗡</code>类。</p><hr><p>接下来我们用<code>getClass()</code>方法获取剑的Class类的实例。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sword</span> s=<span class="function"><span class="keyword">new</span> <span class="title">Sword</span>();</span></span><br><span class="line"><span class="function"><span class="title">Class</span> <span class="title">cl</span>=<span class="title">s</span>.<span class="title">getClass</span>();</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(s.getClass().<span class="title">getName</span>());  <span class="comment">//输出结果为sword.Sword</span></span></span><br></pre></td></tr></table></figure></p><p>以上我们用到了Class类最常用的方法，<code>getName()</code>,它用来返回类的名字.格式为<code>包名.类名</code>.</p><hr><p>如果我们要在程序运行期间读取Class对象，我们可以使用Class类中的<code>forName()</code>方法：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  String className=<span class="string">"sword.Sword"</span>;</span><br><span class="line">  <span class="keyword">Class</span> cl=<span class="keyword">Class</span>.forName(className);</span><br><span class="line">  System.out.<span class="keyword">println</span>(cl.getName()); <span class="comment">//输出同上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上面使用try块来检查异常，原因是因为className可能为<code>不存在</code>的类.</p><hr><p>反射库中还有一个非常实用的方法newInstance(),它用来创建一个类的实例。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">s</span><span class="selector-class">.getClass</span>()<span class="selector-class">.newInstance</span>();</span><br></pre></td></tr></table></figure></p><p>不过<code>newInstance()</code>方法需要调用默认的构造器，如果这个类没有默认的构造器，就会<code>抛出一个异常</code></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><em><code>java.lang.Class</code></em><br>1.static Class forName(String className)<br>  <code>返回描述类名为className的Class对象。</code><br>2.Object newInstance()<br>  <code>返回这个类的一个新实例。</code><br>3.Class getClass()<br>  <code>返回这个类的Class对象。</code><br>4.String getName()<br>  <code>返回该Class对象的类名。</code></p><hr><p>待续</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
